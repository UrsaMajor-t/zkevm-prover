// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: hashdb.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_hashdb_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_hashdb_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3012000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3012004 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/map.h>  // IWYU pragma: export
#include <google/protobuf/map_entry.h>
#include <google/protobuf/map_field_inl.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include <google/protobuf/empty.pb.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_hashdb_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_hashdb_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxillaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[29]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const ::PROTOBUF_NAMESPACE_ID::uint32 offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_hashdb_2eproto;
namespace hashdb {
namespace v1 {
class FeList;
class FeListDefaultTypeInternal;
extern FeListDefaultTypeInternal _FeList_default_instance_;
class Fea;
class FeaDefaultTypeInternal;
extern FeaDefaultTypeInternal _Fea_default_instance_;
class FlushRequest;
class FlushRequestDefaultTypeInternal;
extern FlushRequestDefaultTypeInternal _FlushRequest_default_instance_;
class FlushResponse;
class FlushResponseDefaultTypeInternal;
extern FlushResponseDefaultTypeInternal _FlushResponse_default_instance_;
class GetFlushDataRequest;
class GetFlushDataRequestDefaultTypeInternal;
extern GetFlushDataRequestDefaultTypeInternal _GetFlushDataRequest_default_instance_;
class GetFlushDataResponse;
class GetFlushDataResponseDefaultTypeInternal;
extern GetFlushDataResponseDefaultTypeInternal _GetFlushDataResponse_default_instance_;
class GetFlushDataResponse_NodesEntry_DoNotUse;
class GetFlushDataResponse_NodesEntry_DoNotUseDefaultTypeInternal;
extern GetFlushDataResponse_NodesEntry_DoNotUseDefaultTypeInternal _GetFlushDataResponse_NodesEntry_DoNotUse_default_instance_;
class GetFlushDataResponse_ProgramEntry_DoNotUse;
class GetFlushDataResponse_ProgramEntry_DoNotUseDefaultTypeInternal;
extern GetFlushDataResponse_ProgramEntry_DoNotUseDefaultTypeInternal _GetFlushDataResponse_ProgramEntry_DoNotUse_default_instance_;
class GetFlushStatusResponse;
class GetFlushStatusResponseDefaultTypeInternal;
extern GetFlushStatusResponseDefaultTypeInternal _GetFlushStatusResponse_default_instance_;
class GetProgramRequest;
class GetProgramRequestDefaultTypeInternal;
extern GetProgramRequestDefaultTypeInternal _GetProgramRequest_default_instance_;
class GetProgramResponse;
class GetProgramResponseDefaultTypeInternal;
extern GetProgramResponseDefaultTypeInternal _GetProgramResponse_default_instance_;
class GetRequest;
class GetRequestDefaultTypeInternal;
extern GetRequestDefaultTypeInternal _GetRequest_default_instance_;
class GetResponse;
class GetResponseDefaultTypeInternal;
extern GetResponseDefaultTypeInternal _GetResponse_default_instance_;
class GetResponse_DbReadLogEntry_DoNotUse;
class GetResponse_DbReadLogEntry_DoNotUseDefaultTypeInternal;
extern GetResponse_DbReadLogEntry_DoNotUseDefaultTypeInternal _GetResponse_DbReadLogEntry_DoNotUse_default_instance_;
class GetResponse_SiblingsEntry_DoNotUse;
class GetResponse_SiblingsEntry_DoNotUseDefaultTypeInternal;
extern GetResponse_SiblingsEntry_DoNotUseDefaultTypeInternal _GetResponse_SiblingsEntry_DoNotUse_default_instance_;
class LoadDBRequest;
class LoadDBRequestDefaultTypeInternal;
extern LoadDBRequestDefaultTypeInternal _LoadDBRequest_default_instance_;
class LoadDBRequest_InputDbEntry_DoNotUse;
class LoadDBRequest_InputDbEntry_DoNotUseDefaultTypeInternal;
extern LoadDBRequest_InputDbEntry_DoNotUseDefaultTypeInternal _LoadDBRequest_InputDbEntry_DoNotUse_default_instance_;
class LoadProgramDBRequest;
class LoadProgramDBRequestDefaultTypeInternal;
extern LoadProgramDBRequestDefaultTypeInternal _LoadProgramDBRequest_default_instance_;
class LoadProgramDBRequest_InputProgramDbEntry_DoNotUse;
class LoadProgramDBRequest_InputProgramDbEntry_DoNotUseDefaultTypeInternal;
extern LoadProgramDBRequest_InputProgramDbEntry_DoNotUseDefaultTypeInternal _LoadProgramDBRequest_InputProgramDbEntry_DoNotUse_default_instance_;
class ResultCode;
class ResultCodeDefaultTypeInternal;
extern ResultCodeDefaultTypeInternal _ResultCode_default_instance_;
class SemiFlushRequest;
class SemiFlushRequestDefaultTypeInternal;
extern SemiFlushRequestDefaultTypeInternal _SemiFlushRequest_default_instance_;
class SetProgramRequest;
class SetProgramRequestDefaultTypeInternal;
extern SetProgramRequestDefaultTypeInternal _SetProgramRequest_default_instance_;
class SetProgramResponse;
class SetProgramResponseDefaultTypeInternal;
extern SetProgramResponseDefaultTypeInternal _SetProgramResponse_default_instance_;
class SetRequest;
class SetRequestDefaultTypeInternal;
extern SetRequestDefaultTypeInternal _SetRequest_default_instance_;
class SetResponse;
class SetResponseDefaultTypeInternal;
extern SetResponseDefaultTypeInternal _SetResponse_default_instance_;
class SetResponse_DbReadLogEntry_DoNotUse;
class SetResponse_DbReadLogEntry_DoNotUseDefaultTypeInternal;
extern SetResponse_DbReadLogEntry_DoNotUseDefaultTypeInternal _SetResponse_DbReadLogEntry_DoNotUse_default_instance_;
class SetResponse_SiblingsEntry_DoNotUse;
class SetResponse_SiblingsEntry_DoNotUseDefaultTypeInternal;
extern SetResponse_SiblingsEntry_DoNotUseDefaultTypeInternal _SetResponse_SiblingsEntry_DoNotUse_default_instance_;
class SiblingList;
class SiblingListDefaultTypeInternal;
extern SiblingListDefaultTypeInternal _SiblingList_default_instance_;
class Version;
class VersionDefaultTypeInternal;
extern VersionDefaultTypeInternal _Version_default_instance_;
}  // namespace v1
}  // namespace hashdb
PROTOBUF_NAMESPACE_OPEN
template<> ::hashdb::v1::FeList* Arena::CreateMaybeMessage<::hashdb::v1::FeList>(Arena*);
template<> ::hashdb::v1::Fea* Arena::CreateMaybeMessage<::hashdb::v1::Fea>(Arena*);
template<> ::hashdb::v1::FlushRequest* Arena::CreateMaybeMessage<::hashdb::v1::FlushRequest>(Arena*);
template<> ::hashdb::v1::FlushResponse* Arena::CreateMaybeMessage<::hashdb::v1::FlushResponse>(Arena*);
template<> ::hashdb::v1::GetFlushDataRequest* Arena::CreateMaybeMessage<::hashdb::v1::GetFlushDataRequest>(Arena*);
template<> ::hashdb::v1::GetFlushDataResponse* Arena::CreateMaybeMessage<::hashdb::v1::GetFlushDataResponse>(Arena*);
template<> ::hashdb::v1::GetFlushDataResponse_NodesEntry_DoNotUse* Arena::CreateMaybeMessage<::hashdb::v1::GetFlushDataResponse_NodesEntry_DoNotUse>(Arena*);
template<> ::hashdb::v1::GetFlushDataResponse_ProgramEntry_DoNotUse* Arena::CreateMaybeMessage<::hashdb::v1::GetFlushDataResponse_ProgramEntry_DoNotUse>(Arena*);
template<> ::hashdb::v1::GetFlushStatusResponse* Arena::CreateMaybeMessage<::hashdb::v1::GetFlushStatusResponse>(Arena*);
template<> ::hashdb::v1::GetProgramRequest* Arena::CreateMaybeMessage<::hashdb::v1::GetProgramRequest>(Arena*);
template<> ::hashdb::v1::GetProgramResponse* Arena::CreateMaybeMessage<::hashdb::v1::GetProgramResponse>(Arena*);
template<> ::hashdb::v1::GetRequest* Arena::CreateMaybeMessage<::hashdb::v1::GetRequest>(Arena*);
template<> ::hashdb::v1::GetResponse* Arena::CreateMaybeMessage<::hashdb::v1::GetResponse>(Arena*);
template<> ::hashdb::v1::GetResponse_DbReadLogEntry_DoNotUse* Arena::CreateMaybeMessage<::hashdb::v1::GetResponse_DbReadLogEntry_DoNotUse>(Arena*);
template<> ::hashdb::v1::GetResponse_SiblingsEntry_DoNotUse* Arena::CreateMaybeMessage<::hashdb::v1::GetResponse_SiblingsEntry_DoNotUse>(Arena*);
template<> ::hashdb::v1::LoadDBRequest* Arena::CreateMaybeMessage<::hashdb::v1::LoadDBRequest>(Arena*);
template<> ::hashdb::v1::LoadDBRequest_InputDbEntry_DoNotUse* Arena::CreateMaybeMessage<::hashdb::v1::LoadDBRequest_InputDbEntry_DoNotUse>(Arena*);
template<> ::hashdb::v1::LoadProgramDBRequest* Arena::CreateMaybeMessage<::hashdb::v1::LoadProgramDBRequest>(Arena*);
template<> ::hashdb::v1::LoadProgramDBRequest_InputProgramDbEntry_DoNotUse* Arena::CreateMaybeMessage<::hashdb::v1::LoadProgramDBRequest_InputProgramDbEntry_DoNotUse>(Arena*);
template<> ::hashdb::v1::ResultCode* Arena::CreateMaybeMessage<::hashdb::v1::ResultCode>(Arena*);
template<> ::hashdb::v1::SemiFlushRequest* Arena::CreateMaybeMessage<::hashdb::v1::SemiFlushRequest>(Arena*);
template<> ::hashdb::v1::SetProgramRequest* Arena::CreateMaybeMessage<::hashdb::v1::SetProgramRequest>(Arena*);
template<> ::hashdb::v1::SetProgramResponse* Arena::CreateMaybeMessage<::hashdb::v1::SetProgramResponse>(Arena*);
template<> ::hashdb::v1::SetRequest* Arena::CreateMaybeMessage<::hashdb::v1::SetRequest>(Arena*);
template<> ::hashdb::v1::SetResponse* Arena::CreateMaybeMessage<::hashdb::v1::SetResponse>(Arena*);
template<> ::hashdb::v1::SetResponse_DbReadLogEntry_DoNotUse* Arena::CreateMaybeMessage<::hashdb::v1::SetResponse_DbReadLogEntry_DoNotUse>(Arena*);
template<> ::hashdb::v1::SetResponse_SiblingsEntry_DoNotUse* Arena::CreateMaybeMessage<::hashdb::v1::SetResponse_SiblingsEntry_DoNotUse>(Arena*);
template<> ::hashdb::v1::SiblingList* Arena::CreateMaybeMessage<::hashdb::v1::SiblingList>(Arena*);
template<> ::hashdb::v1::Version* Arena::CreateMaybeMessage<::hashdb::v1::Version>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace hashdb {
namespace v1 {

enum ResultCode_Code : int {
  ResultCode_Code_CODE_UNSPECIFIED = 0,
  ResultCode_Code_CODE_SUCCESS = 1,
  ResultCode_Code_CODE_DB_KEY_NOT_FOUND = 2,
  ResultCode_Code_CODE_DB_ERROR = 3,
  ResultCode_Code_CODE_INTERNAL_ERROR = 4,
  ResultCode_Code_CODE_SMT_INVALID_DATA_SIZE = 14,
  ResultCode_Code_ResultCode_Code_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  ResultCode_Code_ResultCode_Code_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool ResultCode_Code_IsValid(int value);
constexpr ResultCode_Code ResultCode_Code_Code_MIN = ResultCode_Code_CODE_UNSPECIFIED;
constexpr ResultCode_Code ResultCode_Code_Code_MAX = ResultCode_Code_CODE_SMT_INVALID_DATA_SIZE;
constexpr int ResultCode_Code_Code_ARRAYSIZE = ResultCode_Code_Code_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ResultCode_Code_descriptor();
template<typename T>
inline const std::string& ResultCode_Code_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ResultCode_Code>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ResultCode_Code_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    ResultCode_Code_descriptor(), enum_t_value);
}
inline bool ResultCode_Code_Parse(
    const std::string& name, ResultCode_Code* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ResultCode_Code>(
    ResultCode_Code_descriptor(), name, value);
}
enum Persistence : int {
  PERSISTENCE_CACHE_UNSPECIFIED = 0,
  PERSISTENCE_DATABASE = 1,
  PERSISTENCE_TEMPORARY = 2,
  Persistence_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  Persistence_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool Persistence_IsValid(int value);
constexpr Persistence Persistence_MIN = PERSISTENCE_CACHE_UNSPECIFIED;
constexpr Persistence Persistence_MAX = PERSISTENCE_TEMPORARY;
constexpr int Persistence_ARRAYSIZE = Persistence_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Persistence_descriptor();
template<typename T>
inline const std::string& Persistence_Name(T enum_t_value) {
  static_assert(::std::is_same<T, Persistence>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function Persistence_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    Persistence_descriptor(), enum_t_value);
}
inline bool Persistence_Parse(
    const std::string& name, Persistence* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<Persistence>(
    Persistence_descriptor(), name, value);
}
// ===================================================================

class Version PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:hashdb.v1.Version) */ {
 public:
  inline Version() : Version(nullptr) {};
  virtual ~Version();

  Version(const Version& from);
  Version(Version&& from) noexcept
    : Version() {
    *this = ::std::move(from);
  }

  inline Version& operator=(const Version& from) {
    CopyFrom(from);
    return *this;
  }
  inline Version& operator=(Version&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Version& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Version* internal_default_instance() {
    return reinterpret_cast<const Version*>(
               &_Version_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(Version& a, Version& b) {
    a.Swap(&b);
  }
  inline void Swap(Version* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Version* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Version* New() const final {
    return CreateMaybeMessage<Version>(nullptr);
  }

  Version* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Version>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Version& from);
  void MergeFrom(const Version& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Version* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "hashdb.v1.Version";
  }
  protected:
  explicit Version(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_hashdb_2eproto);
    return ::descriptor_table_hashdb_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kV001FieldNumber = 1,
  };
  // string v0_0_1 = 1;
  void clear_v0_0_1();
  const std::string& v0_0_1() const;
  void set_v0_0_1(const std::string& value);
  void set_v0_0_1(std::string&& value);
  void set_v0_0_1(const char* value);
  void set_v0_0_1(const char* value, size_t size);
  std::string* mutable_v0_0_1();
  std::string* release_v0_0_1();
  void set_allocated_v0_0_1(std::string* v0_0_1);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_v0_0_1();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_v0_0_1(
      std::string* v0_0_1);
  private:
  const std::string& _internal_v0_0_1() const;
  void _internal_set_v0_0_1(const std::string& value);
  std::string* _internal_mutable_v0_0_1();
  public:

  // @@protoc_insertion_point(class_scope:hashdb.v1.Version)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr v0_0_1_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_hashdb_2eproto;
};
// -------------------------------------------------------------------

class SetRequest PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:hashdb.v1.SetRequest) */ {
 public:
  inline SetRequest() : SetRequest(nullptr) {};
  virtual ~SetRequest();

  SetRequest(const SetRequest& from);
  SetRequest(SetRequest&& from) noexcept
    : SetRequest() {
    *this = ::std::move(from);
  }

  inline SetRequest& operator=(const SetRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline SetRequest& operator=(SetRequest&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const SetRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SetRequest* internal_default_instance() {
    return reinterpret_cast<const SetRequest*>(
               &_SetRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(SetRequest& a, SetRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(SetRequest* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SetRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline SetRequest* New() const final {
    return CreateMaybeMessage<SetRequest>(nullptr);
  }

  SetRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<SetRequest>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const SetRequest& from);
  void MergeFrom(const SetRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SetRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "hashdb.v1.SetRequest";
  }
  protected:
  explicit SetRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_hashdb_2eproto);
    return ::descriptor_table_hashdb_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kValueFieldNumber = 3,
    kBatchUuidFieldNumber = 7,
    kOldRootFieldNumber = 1,
    kKeyFieldNumber = 2,
    kPersistenceFieldNumber = 4,
    kDetailsFieldNumber = 5,
    kGetDbReadLogFieldNumber = 6,
    kTxFieldNumber = 8,
  };
  // string value = 3;
  void clear_value();
  const std::string& value() const;
  void set_value(const std::string& value);
  void set_value(std::string&& value);
  void set_value(const char* value);
  void set_value(const char* value, size_t size);
  std::string* mutable_value();
  std::string* release_value();
  void set_allocated_value(std::string* value);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_value();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_value(
      std::string* value);
  private:
  const std::string& _internal_value() const;
  void _internal_set_value(const std::string& value);
  std::string* _internal_mutable_value();
  public:

  // string batch_uuid = 7;
  void clear_batch_uuid();
  const std::string& batch_uuid() const;
  void set_batch_uuid(const std::string& value);
  void set_batch_uuid(std::string&& value);
  void set_batch_uuid(const char* value);
  void set_batch_uuid(const char* value, size_t size);
  std::string* mutable_batch_uuid();
  std::string* release_batch_uuid();
  void set_allocated_batch_uuid(std::string* batch_uuid);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_batch_uuid();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_batch_uuid(
      std::string* batch_uuid);
  private:
  const std::string& _internal_batch_uuid() const;
  void _internal_set_batch_uuid(const std::string& value);
  std::string* _internal_mutable_batch_uuid();
  public:

  // .hashdb.v1.Fea old_root = 1;
  bool has_old_root() const;
  private:
  bool _internal_has_old_root() const;
  public:
  void clear_old_root();
  const ::hashdb::v1::Fea& old_root() const;
  ::hashdb::v1::Fea* release_old_root();
  ::hashdb::v1::Fea* mutable_old_root();
  void set_allocated_old_root(::hashdb::v1::Fea* old_root);
  private:
  const ::hashdb::v1::Fea& _internal_old_root() const;
  ::hashdb::v1::Fea* _internal_mutable_old_root();
  public:
  void unsafe_arena_set_allocated_old_root(
      ::hashdb::v1::Fea* old_root);
  ::hashdb::v1::Fea* unsafe_arena_release_old_root();

  // .hashdb.v1.Fea key = 2;
  bool has_key() const;
  private:
  bool _internal_has_key() const;
  public:
  void clear_key();
  const ::hashdb::v1::Fea& key() const;
  ::hashdb::v1::Fea* release_key();
  ::hashdb::v1::Fea* mutable_key();
  void set_allocated_key(::hashdb::v1::Fea* key);
  private:
  const ::hashdb::v1::Fea& _internal_key() const;
  ::hashdb::v1::Fea* _internal_mutable_key();
  public:
  void unsafe_arena_set_allocated_key(
      ::hashdb::v1::Fea* key);
  ::hashdb::v1::Fea* unsafe_arena_release_key();

  // .hashdb.v1.Persistence persistence = 4;
  void clear_persistence();
  ::hashdb::v1::Persistence persistence() const;
  void set_persistence(::hashdb::v1::Persistence value);
  private:
  ::hashdb::v1::Persistence _internal_persistence() const;
  void _internal_set_persistence(::hashdb::v1::Persistence value);
  public:

  // bool details = 5;
  void clear_details();
  bool details() const;
  void set_details(bool value);
  private:
  bool _internal_details() const;
  void _internal_set_details(bool value);
  public:

  // bool get_db_read_log = 6;
  void clear_get_db_read_log();
  bool get_db_read_log() const;
  void set_get_db_read_log(bool value);
  private:
  bool _internal_get_db_read_log() const;
  void _internal_set_get_db_read_log(bool value);
  public:

  // uint64 tx = 8;
  void clear_tx();
  ::PROTOBUF_NAMESPACE_ID::uint64 tx() const;
  void set_tx(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_tx() const;
  void _internal_set_tx(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // @@protoc_insertion_point(class_scope:hashdb.v1.SetRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr value_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr batch_uuid_;
  ::hashdb::v1::Fea* old_root_;
  ::hashdb::v1::Fea* key_;
  int persistence_;
  bool details_;
  bool get_db_read_log_;
  ::PROTOBUF_NAMESPACE_ID::uint64 tx_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_hashdb_2eproto;
};
// -------------------------------------------------------------------

class GetRequest PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:hashdb.v1.GetRequest) */ {
 public:
  inline GetRequest() : GetRequest(nullptr) {};
  virtual ~GetRequest();

  GetRequest(const GetRequest& from);
  GetRequest(GetRequest&& from) noexcept
    : GetRequest() {
    *this = ::std::move(from);
  }

  inline GetRequest& operator=(const GetRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetRequest& operator=(GetRequest&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const GetRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const GetRequest* internal_default_instance() {
    return reinterpret_cast<const GetRequest*>(
               &_GetRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(GetRequest& a, GetRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(GetRequest* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline GetRequest* New() const final {
    return CreateMaybeMessage<GetRequest>(nullptr);
  }

  GetRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<GetRequest>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const GetRequest& from);
  void MergeFrom(const GetRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "hashdb.v1.GetRequest";
  }
  protected:
  explicit GetRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_hashdb_2eproto);
    return ::descriptor_table_hashdb_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kBatchUuidFieldNumber = 5,
    kRootFieldNumber = 1,
    kKeyFieldNumber = 2,
    kDetailsFieldNumber = 3,
    kGetDbReadLogFieldNumber = 4,
  };
  // string batch_uuid = 5;
  void clear_batch_uuid();
  const std::string& batch_uuid() const;
  void set_batch_uuid(const std::string& value);
  void set_batch_uuid(std::string&& value);
  void set_batch_uuid(const char* value);
  void set_batch_uuid(const char* value, size_t size);
  std::string* mutable_batch_uuid();
  std::string* release_batch_uuid();
  void set_allocated_batch_uuid(std::string* batch_uuid);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_batch_uuid();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_batch_uuid(
      std::string* batch_uuid);
  private:
  const std::string& _internal_batch_uuid() const;
  void _internal_set_batch_uuid(const std::string& value);
  std::string* _internal_mutable_batch_uuid();
  public:

  // .hashdb.v1.Fea root = 1;
  bool has_root() const;
  private:
  bool _internal_has_root() const;
  public:
  void clear_root();
  const ::hashdb::v1::Fea& root() const;
  ::hashdb::v1::Fea* release_root();
  ::hashdb::v1::Fea* mutable_root();
  void set_allocated_root(::hashdb::v1::Fea* root);
  private:
  const ::hashdb::v1::Fea& _internal_root() const;
  ::hashdb::v1::Fea* _internal_mutable_root();
  public:
  void unsafe_arena_set_allocated_root(
      ::hashdb::v1::Fea* root);
  ::hashdb::v1::Fea* unsafe_arena_release_root();

  // .hashdb.v1.Fea key = 2;
  bool has_key() const;
  private:
  bool _internal_has_key() const;
  public:
  void clear_key();
  const ::hashdb::v1::Fea& key() const;
  ::hashdb::v1::Fea* release_key();
  ::hashdb::v1::Fea* mutable_key();
  void set_allocated_key(::hashdb::v1::Fea* key);
  private:
  const ::hashdb::v1::Fea& _internal_key() const;
  ::hashdb::v1::Fea* _internal_mutable_key();
  public:
  void unsafe_arena_set_allocated_key(
      ::hashdb::v1::Fea* key);
  ::hashdb::v1::Fea* unsafe_arena_release_key();

  // bool details = 3;
  void clear_details();
  bool details() const;
  void set_details(bool value);
  private:
  bool _internal_details() const;
  void _internal_set_details(bool value);
  public:

  // bool get_db_read_log = 4;
  void clear_get_db_read_log();
  bool get_db_read_log() const;
  void set_get_db_read_log(bool value);
  private:
  bool _internal_get_db_read_log() const;
  void _internal_set_get_db_read_log(bool value);
  public:

  // @@protoc_insertion_point(class_scope:hashdb.v1.GetRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr batch_uuid_;
  ::hashdb::v1::Fea* root_;
  ::hashdb::v1::Fea* key_;
  bool details_;
  bool get_db_read_log_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_hashdb_2eproto;
};
// -------------------------------------------------------------------

class SetProgramRequest PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:hashdb.v1.SetProgramRequest) */ {
 public:
  inline SetProgramRequest() : SetProgramRequest(nullptr) {};
  virtual ~SetProgramRequest();

  SetProgramRequest(const SetProgramRequest& from);
  SetProgramRequest(SetProgramRequest&& from) noexcept
    : SetProgramRequest() {
    *this = ::std::move(from);
  }

  inline SetProgramRequest& operator=(const SetProgramRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline SetProgramRequest& operator=(SetProgramRequest&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const SetProgramRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SetProgramRequest* internal_default_instance() {
    return reinterpret_cast<const SetProgramRequest*>(
               &_SetProgramRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(SetProgramRequest& a, SetProgramRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(SetProgramRequest* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SetProgramRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline SetProgramRequest* New() const final {
    return CreateMaybeMessage<SetProgramRequest>(nullptr);
  }

  SetProgramRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<SetProgramRequest>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const SetProgramRequest& from);
  void MergeFrom(const SetProgramRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SetProgramRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "hashdb.v1.SetProgramRequest";
  }
  protected:
  explicit SetProgramRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_hashdb_2eproto);
    return ::descriptor_table_hashdb_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDataFieldNumber = 2,
    kKeyFieldNumber = 1,
    kPersistentFieldNumber = 3,
  };
  // bytes data = 2;
  void clear_data();
  const std::string& data() const;
  void set_data(const std::string& value);
  void set_data(std::string&& value);
  void set_data(const char* value);
  void set_data(const void* value, size_t size);
  std::string* mutable_data();
  std::string* release_data();
  void set_allocated_data(std::string* data);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_data();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_data(
      std::string* data);
  private:
  const std::string& _internal_data() const;
  void _internal_set_data(const std::string& value);
  std::string* _internal_mutable_data();
  public:

  // .hashdb.v1.Fea key = 1;
  bool has_key() const;
  private:
  bool _internal_has_key() const;
  public:
  void clear_key();
  const ::hashdb::v1::Fea& key() const;
  ::hashdb::v1::Fea* release_key();
  ::hashdb::v1::Fea* mutable_key();
  void set_allocated_key(::hashdb::v1::Fea* key);
  private:
  const ::hashdb::v1::Fea& _internal_key() const;
  ::hashdb::v1::Fea* _internal_mutable_key();
  public:
  void unsafe_arena_set_allocated_key(
      ::hashdb::v1::Fea* key);
  ::hashdb::v1::Fea* unsafe_arena_release_key();

  // bool persistent = 3;
  void clear_persistent();
  bool persistent() const;
  void set_persistent(bool value);
  private:
  bool _internal_persistent() const;
  void _internal_set_persistent(bool value);
  public:

  // @@protoc_insertion_point(class_scope:hashdb.v1.SetProgramRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr data_;
  ::hashdb::v1::Fea* key_;
  bool persistent_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_hashdb_2eproto;
};
// -------------------------------------------------------------------

class GetProgramRequest PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:hashdb.v1.GetProgramRequest) */ {
 public:
  inline GetProgramRequest() : GetProgramRequest(nullptr) {};
  virtual ~GetProgramRequest();

  GetProgramRequest(const GetProgramRequest& from);
  GetProgramRequest(GetProgramRequest&& from) noexcept
    : GetProgramRequest() {
    *this = ::std::move(from);
  }

  inline GetProgramRequest& operator=(const GetProgramRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetProgramRequest& operator=(GetProgramRequest&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const GetProgramRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const GetProgramRequest* internal_default_instance() {
    return reinterpret_cast<const GetProgramRequest*>(
               &_GetProgramRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(GetProgramRequest& a, GetProgramRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(GetProgramRequest* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetProgramRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline GetProgramRequest* New() const final {
    return CreateMaybeMessage<GetProgramRequest>(nullptr);
  }

  GetProgramRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<GetProgramRequest>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const GetProgramRequest& from);
  void MergeFrom(const GetProgramRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetProgramRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "hashdb.v1.GetProgramRequest";
  }
  protected:
  explicit GetProgramRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_hashdb_2eproto);
    return ::descriptor_table_hashdb_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kKeyFieldNumber = 1,
  };
  // .hashdb.v1.Fea key = 1;
  bool has_key() const;
  private:
  bool _internal_has_key() const;
  public:
  void clear_key();
  const ::hashdb::v1::Fea& key() const;
  ::hashdb::v1::Fea* release_key();
  ::hashdb::v1::Fea* mutable_key();
  void set_allocated_key(::hashdb::v1::Fea* key);
  private:
  const ::hashdb::v1::Fea& _internal_key() const;
  ::hashdb::v1::Fea* _internal_mutable_key();
  public:
  void unsafe_arena_set_allocated_key(
      ::hashdb::v1::Fea* key);
  ::hashdb::v1::Fea* unsafe_arena_release_key();

  // @@protoc_insertion_point(class_scope:hashdb.v1.GetProgramRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::hashdb::v1::Fea* key_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_hashdb_2eproto;
};
// -------------------------------------------------------------------

class LoadDBRequest_InputDbEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<LoadDBRequest_InputDbEntry_DoNotUse, 
    std::string, ::hashdb::v1::FeList,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE,
    0 > {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<LoadDBRequest_InputDbEntry_DoNotUse, 
    std::string, ::hashdb::v1::FeList,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE,
    0 > SuperType;
  LoadDBRequest_InputDbEntry_DoNotUse();
  LoadDBRequest_InputDbEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const LoadDBRequest_InputDbEntry_DoNotUse& other);
  static const LoadDBRequest_InputDbEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const LoadDBRequest_InputDbEntry_DoNotUse*>(&_LoadDBRequest_InputDbEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "hashdb.v1.LoadDBRequest.InputDbEntry.key");
 }
  static bool ValidateValue(void*) { return true; }
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& other) final;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_hashdb_2eproto);
    return ::descriptor_table_hashdb_2eproto.file_level_metadata[5];
  }

  public:
};

// -------------------------------------------------------------------

class LoadDBRequest PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:hashdb.v1.LoadDBRequest) */ {
 public:
  inline LoadDBRequest() : LoadDBRequest(nullptr) {};
  virtual ~LoadDBRequest();

  LoadDBRequest(const LoadDBRequest& from);
  LoadDBRequest(LoadDBRequest&& from) noexcept
    : LoadDBRequest() {
    *this = ::std::move(from);
  }

  inline LoadDBRequest& operator=(const LoadDBRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline LoadDBRequest& operator=(LoadDBRequest&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const LoadDBRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const LoadDBRequest* internal_default_instance() {
    return reinterpret_cast<const LoadDBRequest*>(
               &_LoadDBRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(LoadDBRequest& a, LoadDBRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(LoadDBRequest* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LoadDBRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline LoadDBRequest* New() const final {
    return CreateMaybeMessage<LoadDBRequest>(nullptr);
  }

  LoadDBRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<LoadDBRequest>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const LoadDBRequest& from);
  void MergeFrom(const LoadDBRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LoadDBRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "hashdb.v1.LoadDBRequest";
  }
  protected:
  explicit LoadDBRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_hashdb_2eproto);
    return ::descriptor_table_hashdb_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  enum : int {
    kInputDbFieldNumber = 1,
    kPersistentFieldNumber = 2,
  };
  // map<string, .hashdb.v1.FeList> input_db = 1;
  int input_db_size() const;
  private:
  int _internal_input_db_size() const;
  public:
  void clear_input_db();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::hashdb::v1::FeList >&
      _internal_input_db() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::hashdb::v1::FeList >*
      _internal_mutable_input_db();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::hashdb::v1::FeList >&
      input_db() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::hashdb::v1::FeList >*
      mutable_input_db();

  // bool persistent = 2;
  void clear_persistent();
  bool persistent() const;
  void set_persistent(bool value);
  private:
  bool _internal_persistent() const;
  void _internal_set_persistent(bool value);
  public:

  // @@protoc_insertion_point(class_scope:hashdb.v1.LoadDBRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::MapField<
      LoadDBRequest_InputDbEntry_DoNotUse,
      std::string, ::hashdb::v1::FeList,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE,
      0 > input_db_;
  bool persistent_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_hashdb_2eproto;
};
// -------------------------------------------------------------------

class LoadProgramDBRequest_InputProgramDbEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<LoadProgramDBRequest_InputProgramDbEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_BYTES,
    0 > {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<LoadProgramDBRequest_InputProgramDbEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_BYTES,
    0 > SuperType;
  LoadProgramDBRequest_InputProgramDbEntry_DoNotUse();
  LoadProgramDBRequest_InputProgramDbEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const LoadProgramDBRequest_InputProgramDbEntry_DoNotUse& other);
  static const LoadProgramDBRequest_InputProgramDbEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const LoadProgramDBRequest_InputProgramDbEntry_DoNotUse*>(&_LoadProgramDBRequest_InputProgramDbEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "hashdb.v1.LoadProgramDBRequest.InputProgramDbEntry.key");
 }
  static bool ValidateValue(void*) { return true; }
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& other) final;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_hashdb_2eproto);
    return ::descriptor_table_hashdb_2eproto.file_level_metadata[7];
  }

  public:
};

// -------------------------------------------------------------------

class LoadProgramDBRequest PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:hashdb.v1.LoadProgramDBRequest) */ {
 public:
  inline LoadProgramDBRequest() : LoadProgramDBRequest(nullptr) {};
  virtual ~LoadProgramDBRequest();

  LoadProgramDBRequest(const LoadProgramDBRequest& from);
  LoadProgramDBRequest(LoadProgramDBRequest&& from) noexcept
    : LoadProgramDBRequest() {
    *this = ::std::move(from);
  }

  inline LoadProgramDBRequest& operator=(const LoadProgramDBRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline LoadProgramDBRequest& operator=(LoadProgramDBRequest&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const LoadProgramDBRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const LoadProgramDBRequest* internal_default_instance() {
    return reinterpret_cast<const LoadProgramDBRequest*>(
               &_LoadProgramDBRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(LoadProgramDBRequest& a, LoadProgramDBRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(LoadProgramDBRequest* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LoadProgramDBRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline LoadProgramDBRequest* New() const final {
    return CreateMaybeMessage<LoadProgramDBRequest>(nullptr);
  }

  LoadProgramDBRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<LoadProgramDBRequest>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const LoadProgramDBRequest& from);
  void MergeFrom(const LoadProgramDBRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LoadProgramDBRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "hashdb.v1.LoadProgramDBRequest";
  }
  protected:
  explicit LoadProgramDBRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_hashdb_2eproto);
    return ::descriptor_table_hashdb_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  enum : int {
    kInputProgramDbFieldNumber = 1,
    kPersistentFieldNumber = 2,
  };
  // map<string, bytes> input_program_db = 1;
  int input_program_db_size() const;
  private:
  int _internal_input_program_db_size() const;
  public:
  void clear_input_program_db();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      _internal_input_program_db() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      _internal_mutable_input_program_db();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      input_program_db() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      mutable_input_program_db();

  // bool persistent = 2;
  void clear_persistent();
  bool persistent() const;
  void set_persistent(bool value);
  private:
  bool _internal_persistent() const;
  void _internal_set_persistent(bool value);
  public:

  // @@protoc_insertion_point(class_scope:hashdb.v1.LoadProgramDBRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::MapField<
      LoadProgramDBRequest_InputProgramDbEntry_DoNotUse,
      std::string, std::string,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_BYTES,
      0 > input_program_db_;
  bool persistent_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_hashdb_2eproto;
};
// -------------------------------------------------------------------

class FlushRequest PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:hashdb.v1.FlushRequest) */ {
 public:
  inline FlushRequest() : FlushRequest(nullptr) {};
  virtual ~FlushRequest();

  FlushRequest(const FlushRequest& from);
  FlushRequest(FlushRequest&& from) noexcept
    : FlushRequest() {
    *this = ::std::move(from);
  }

  inline FlushRequest& operator=(const FlushRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline FlushRequest& operator=(FlushRequest&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const FlushRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const FlushRequest* internal_default_instance() {
    return reinterpret_cast<const FlushRequest*>(
               &_FlushRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(FlushRequest& a, FlushRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(FlushRequest* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FlushRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline FlushRequest* New() const final {
    return CreateMaybeMessage<FlushRequest>(nullptr);
  }

  FlushRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<FlushRequest>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const FlushRequest& from);
  void MergeFrom(const FlushRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FlushRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "hashdb.v1.FlushRequest";
  }
  protected:
  explicit FlushRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_hashdb_2eproto);
    return ::descriptor_table_hashdb_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kBatchUuidFieldNumber = 1,
    kNewStateRootFieldNumber = 2,
    kPersistenceFieldNumber = 3,
  };
  // string batch_uuid = 1;
  void clear_batch_uuid();
  const std::string& batch_uuid() const;
  void set_batch_uuid(const std::string& value);
  void set_batch_uuid(std::string&& value);
  void set_batch_uuid(const char* value);
  void set_batch_uuid(const char* value, size_t size);
  std::string* mutable_batch_uuid();
  std::string* release_batch_uuid();
  void set_allocated_batch_uuid(std::string* batch_uuid);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_batch_uuid();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_batch_uuid(
      std::string* batch_uuid);
  private:
  const std::string& _internal_batch_uuid() const;
  void _internal_set_batch_uuid(const std::string& value);
  std::string* _internal_mutable_batch_uuid();
  public:

  // string new_state_root = 2;
  void clear_new_state_root();
  const std::string& new_state_root() const;
  void set_new_state_root(const std::string& value);
  void set_new_state_root(std::string&& value);
  void set_new_state_root(const char* value);
  void set_new_state_root(const char* value, size_t size);
  std::string* mutable_new_state_root();
  std::string* release_new_state_root();
  void set_allocated_new_state_root(std::string* new_state_root);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_new_state_root();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_new_state_root(
      std::string* new_state_root);
  private:
  const std::string& _internal_new_state_root() const;
  void _internal_set_new_state_root(const std::string& value);
  std::string* _internal_mutable_new_state_root();
  public:

  // .hashdb.v1.Persistence persistence = 3;
  void clear_persistence();
  ::hashdb::v1::Persistence persistence() const;
  void set_persistence(::hashdb::v1::Persistence value);
  private:
  ::hashdb::v1::Persistence _internal_persistence() const;
  void _internal_set_persistence(::hashdb::v1::Persistence value);
  public:

  // @@protoc_insertion_point(class_scope:hashdb.v1.FlushRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr batch_uuid_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr new_state_root_;
  int persistence_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_hashdb_2eproto;
};
// -------------------------------------------------------------------

class SemiFlushRequest PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:hashdb.v1.SemiFlushRequest) */ {
 public:
  inline SemiFlushRequest() : SemiFlushRequest(nullptr) {};
  virtual ~SemiFlushRequest();

  SemiFlushRequest(const SemiFlushRequest& from);
  SemiFlushRequest(SemiFlushRequest&& from) noexcept
    : SemiFlushRequest() {
    *this = ::std::move(from);
  }

  inline SemiFlushRequest& operator=(const SemiFlushRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline SemiFlushRequest& operator=(SemiFlushRequest&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const SemiFlushRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SemiFlushRequest* internal_default_instance() {
    return reinterpret_cast<const SemiFlushRequest*>(
               &_SemiFlushRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(SemiFlushRequest& a, SemiFlushRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(SemiFlushRequest* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SemiFlushRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline SemiFlushRequest* New() const final {
    return CreateMaybeMessage<SemiFlushRequest>(nullptr);
  }

  SemiFlushRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<SemiFlushRequest>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const SemiFlushRequest& from);
  void MergeFrom(const SemiFlushRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SemiFlushRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "hashdb.v1.SemiFlushRequest";
  }
  protected:
  explicit SemiFlushRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_hashdb_2eproto);
    return ::descriptor_table_hashdb_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kBatchUuidFieldNumber = 1,
    kNewStateRootFieldNumber = 2,
    kPersistenceFieldNumber = 3,
  };
  // string batch_uuid = 1;
  void clear_batch_uuid();
  const std::string& batch_uuid() const;
  void set_batch_uuid(const std::string& value);
  void set_batch_uuid(std::string&& value);
  void set_batch_uuid(const char* value);
  void set_batch_uuid(const char* value, size_t size);
  std::string* mutable_batch_uuid();
  std::string* release_batch_uuid();
  void set_allocated_batch_uuid(std::string* batch_uuid);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_batch_uuid();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_batch_uuid(
      std::string* batch_uuid);
  private:
  const std::string& _internal_batch_uuid() const;
  void _internal_set_batch_uuid(const std::string& value);
  std::string* _internal_mutable_batch_uuid();
  public:

  // string new_state_root = 2;
  void clear_new_state_root();
  const std::string& new_state_root() const;
  void set_new_state_root(const std::string& value);
  void set_new_state_root(std::string&& value);
  void set_new_state_root(const char* value);
  void set_new_state_root(const char* value, size_t size);
  std::string* mutable_new_state_root();
  std::string* release_new_state_root();
  void set_allocated_new_state_root(std::string* new_state_root);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_new_state_root();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_new_state_root(
      std::string* new_state_root);
  private:
  const std::string& _internal_new_state_root() const;
  void _internal_set_new_state_root(const std::string& value);
  std::string* _internal_mutable_new_state_root();
  public:

  // .hashdb.v1.Persistence persistence = 3;
  void clear_persistence();
  ::hashdb::v1::Persistence persistence() const;
  void set_persistence(::hashdb::v1::Persistence value);
  private:
  ::hashdb::v1::Persistence _internal_persistence() const;
  void _internal_set_persistence(::hashdb::v1::Persistence value);
  public:

  // @@protoc_insertion_point(class_scope:hashdb.v1.SemiFlushRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr batch_uuid_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr new_state_root_;
  int persistence_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_hashdb_2eproto;
};
// -------------------------------------------------------------------

class GetFlushDataRequest PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:hashdb.v1.GetFlushDataRequest) */ {
 public:
  inline GetFlushDataRequest() : GetFlushDataRequest(nullptr) {};
  virtual ~GetFlushDataRequest();

  GetFlushDataRequest(const GetFlushDataRequest& from);
  GetFlushDataRequest(GetFlushDataRequest&& from) noexcept
    : GetFlushDataRequest() {
    *this = ::std::move(from);
  }

  inline GetFlushDataRequest& operator=(const GetFlushDataRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetFlushDataRequest& operator=(GetFlushDataRequest&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const GetFlushDataRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const GetFlushDataRequest* internal_default_instance() {
    return reinterpret_cast<const GetFlushDataRequest*>(
               &_GetFlushDataRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(GetFlushDataRequest& a, GetFlushDataRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(GetFlushDataRequest* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetFlushDataRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline GetFlushDataRequest* New() const final {
    return CreateMaybeMessage<GetFlushDataRequest>(nullptr);
  }

  GetFlushDataRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<GetFlushDataRequest>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const GetFlushDataRequest& from);
  void MergeFrom(const GetFlushDataRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetFlushDataRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "hashdb.v1.GetFlushDataRequest";
  }
  protected:
  explicit GetFlushDataRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_hashdb_2eproto);
    return ::descriptor_table_hashdb_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFlushIdFieldNumber = 1,
  };
  // uint64 flush_id = 1;
  void clear_flush_id();
  ::PROTOBUF_NAMESPACE_ID::uint64 flush_id() const;
  void set_flush_id(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_flush_id() const;
  void _internal_set_flush_id(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // @@protoc_insertion_point(class_scope:hashdb.v1.GetFlushDataRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::uint64 flush_id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_hashdb_2eproto;
};
// -------------------------------------------------------------------

class SetResponse_SiblingsEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<SetResponse_SiblingsEntry_DoNotUse, 
    ::PROTOBUF_NAMESPACE_ID::uint64, ::hashdb::v1::SiblingList,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT64,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE,
    0 > {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<SetResponse_SiblingsEntry_DoNotUse, 
    ::PROTOBUF_NAMESPACE_ID::uint64, ::hashdb::v1::SiblingList,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT64,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE,
    0 > SuperType;
  SetResponse_SiblingsEntry_DoNotUse();
  SetResponse_SiblingsEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const SetResponse_SiblingsEntry_DoNotUse& other);
  static const SetResponse_SiblingsEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const SetResponse_SiblingsEntry_DoNotUse*>(&_SetResponse_SiblingsEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(void*) { return true; }
  static bool ValidateValue(void*) { return true; }
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& other) final;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_hashdb_2eproto);
    return ::descriptor_table_hashdb_2eproto.file_level_metadata[12];
  }

  public:
};

// -------------------------------------------------------------------

class SetResponse_DbReadLogEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<SetResponse_DbReadLogEntry_DoNotUse, 
    std::string, ::hashdb::v1::FeList,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE,
    0 > {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<SetResponse_DbReadLogEntry_DoNotUse, 
    std::string, ::hashdb::v1::FeList,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE,
    0 > SuperType;
  SetResponse_DbReadLogEntry_DoNotUse();
  SetResponse_DbReadLogEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const SetResponse_DbReadLogEntry_DoNotUse& other);
  static const SetResponse_DbReadLogEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const SetResponse_DbReadLogEntry_DoNotUse*>(&_SetResponse_DbReadLogEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "hashdb.v1.SetResponse.DbReadLogEntry.key");
 }
  static bool ValidateValue(void*) { return true; }
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& other) final;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_hashdb_2eproto);
    return ::descriptor_table_hashdb_2eproto.file_level_metadata[13];
  }

  public:
};

// -------------------------------------------------------------------

class SetResponse PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:hashdb.v1.SetResponse) */ {
 public:
  inline SetResponse() : SetResponse(nullptr) {};
  virtual ~SetResponse();

  SetResponse(const SetResponse& from);
  SetResponse(SetResponse&& from) noexcept
    : SetResponse() {
    *this = ::std::move(from);
  }

  inline SetResponse& operator=(const SetResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline SetResponse& operator=(SetResponse&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const SetResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SetResponse* internal_default_instance() {
    return reinterpret_cast<const SetResponse*>(
               &_SetResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  friend void swap(SetResponse& a, SetResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(SetResponse* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SetResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline SetResponse* New() const final {
    return CreateMaybeMessage<SetResponse>(nullptr);
  }

  SetResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<SetResponse>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const SetResponse& from);
  void MergeFrom(const SetResponse& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SetResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "hashdb.v1.SetResponse";
  }
  protected:
  explicit SetResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_hashdb_2eproto);
    return ::descriptor_table_hashdb_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  enum : int {
    kSiblingsFieldNumber = 4,
    kDbReadLogFieldNumber = 12,
    kInsValueFieldNumber = 6,
    kOldValueFieldNumber = 8,
    kNewValueFieldNumber = 9,
    kModeFieldNumber = 10,
    kOldRootFieldNumber = 1,
    kNewRootFieldNumber = 2,
    kKeyFieldNumber = 3,
    kInsKeyFieldNumber = 5,
    kResultFieldNumber = 13,
    kProofHashCounterFieldNumber = 11,
    kIsOld0FieldNumber = 7,
  };
  // map<uint64, .hashdb.v1.SiblingList> siblings = 4;
  int siblings_size() const;
  private:
  int _internal_siblings_size() const;
  public:
  void clear_siblings();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< ::PROTOBUF_NAMESPACE_ID::uint64, ::hashdb::v1::SiblingList >&
      _internal_siblings() const;
  ::PROTOBUF_NAMESPACE_ID::Map< ::PROTOBUF_NAMESPACE_ID::uint64, ::hashdb::v1::SiblingList >*
      _internal_mutable_siblings();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< ::PROTOBUF_NAMESPACE_ID::uint64, ::hashdb::v1::SiblingList >&
      siblings() const;
  ::PROTOBUF_NAMESPACE_ID::Map< ::PROTOBUF_NAMESPACE_ID::uint64, ::hashdb::v1::SiblingList >*
      mutable_siblings();

  // map<string, .hashdb.v1.FeList> db_read_log = 12;
  int db_read_log_size() const;
  private:
  int _internal_db_read_log_size() const;
  public:
  void clear_db_read_log();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::hashdb::v1::FeList >&
      _internal_db_read_log() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::hashdb::v1::FeList >*
      _internal_mutable_db_read_log();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::hashdb::v1::FeList >&
      db_read_log() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::hashdb::v1::FeList >*
      mutable_db_read_log();

  // string ins_value = 6;
  void clear_ins_value();
  const std::string& ins_value() const;
  void set_ins_value(const std::string& value);
  void set_ins_value(std::string&& value);
  void set_ins_value(const char* value);
  void set_ins_value(const char* value, size_t size);
  std::string* mutable_ins_value();
  std::string* release_ins_value();
  void set_allocated_ins_value(std::string* ins_value);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_ins_value();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_ins_value(
      std::string* ins_value);
  private:
  const std::string& _internal_ins_value() const;
  void _internal_set_ins_value(const std::string& value);
  std::string* _internal_mutable_ins_value();
  public:

  // string old_value = 8;
  void clear_old_value();
  const std::string& old_value() const;
  void set_old_value(const std::string& value);
  void set_old_value(std::string&& value);
  void set_old_value(const char* value);
  void set_old_value(const char* value, size_t size);
  std::string* mutable_old_value();
  std::string* release_old_value();
  void set_allocated_old_value(std::string* old_value);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_old_value();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_old_value(
      std::string* old_value);
  private:
  const std::string& _internal_old_value() const;
  void _internal_set_old_value(const std::string& value);
  std::string* _internal_mutable_old_value();
  public:

  // string new_value = 9;
  void clear_new_value();
  const std::string& new_value() const;
  void set_new_value(const std::string& value);
  void set_new_value(std::string&& value);
  void set_new_value(const char* value);
  void set_new_value(const char* value, size_t size);
  std::string* mutable_new_value();
  std::string* release_new_value();
  void set_allocated_new_value(std::string* new_value);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_new_value();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_new_value(
      std::string* new_value);
  private:
  const std::string& _internal_new_value() const;
  void _internal_set_new_value(const std::string& value);
  std::string* _internal_mutable_new_value();
  public:

  // string mode = 10;
  void clear_mode();
  const std::string& mode() const;
  void set_mode(const std::string& value);
  void set_mode(std::string&& value);
  void set_mode(const char* value);
  void set_mode(const char* value, size_t size);
  std::string* mutable_mode();
  std::string* release_mode();
  void set_allocated_mode(std::string* mode);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_mode();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_mode(
      std::string* mode);
  private:
  const std::string& _internal_mode() const;
  void _internal_set_mode(const std::string& value);
  std::string* _internal_mutable_mode();
  public:

  // .hashdb.v1.Fea old_root = 1;
  bool has_old_root() const;
  private:
  bool _internal_has_old_root() const;
  public:
  void clear_old_root();
  const ::hashdb::v1::Fea& old_root() const;
  ::hashdb::v1::Fea* release_old_root();
  ::hashdb::v1::Fea* mutable_old_root();
  void set_allocated_old_root(::hashdb::v1::Fea* old_root);
  private:
  const ::hashdb::v1::Fea& _internal_old_root() const;
  ::hashdb::v1::Fea* _internal_mutable_old_root();
  public:
  void unsafe_arena_set_allocated_old_root(
      ::hashdb::v1::Fea* old_root);
  ::hashdb::v1::Fea* unsafe_arena_release_old_root();

  // .hashdb.v1.Fea new_root = 2;
  bool has_new_root() const;
  private:
  bool _internal_has_new_root() const;
  public:
  void clear_new_root();
  const ::hashdb::v1::Fea& new_root() const;
  ::hashdb::v1::Fea* release_new_root();
  ::hashdb::v1::Fea* mutable_new_root();
  void set_allocated_new_root(::hashdb::v1::Fea* new_root);
  private:
  const ::hashdb::v1::Fea& _internal_new_root() const;
  ::hashdb::v1::Fea* _internal_mutable_new_root();
  public:
  void unsafe_arena_set_allocated_new_root(
      ::hashdb::v1::Fea* new_root);
  ::hashdb::v1::Fea* unsafe_arena_release_new_root();

  // .hashdb.v1.Fea key = 3;
  bool has_key() const;
  private:
  bool _internal_has_key() const;
  public:
  void clear_key();
  const ::hashdb::v1::Fea& key() const;
  ::hashdb::v1::Fea* release_key();
  ::hashdb::v1::Fea* mutable_key();
  void set_allocated_key(::hashdb::v1::Fea* key);
  private:
  const ::hashdb::v1::Fea& _internal_key() const;
  ::hashdb::v1::Fea* _internal_mutable_key();
  public:
  void unsafe_arena_set_allocated_key(
      ::hashdb::v1::Fea* key);
  ::hashdb::v1::Fea* unsafe_arena_release_key();

  // .hashdb.v1.Fea ins_key = 5;
  bool has_ins_key() const;
  private:
  bool _internal_has_ins_key() const;
  public:
  void clear_ins_key();
  const ::hashdb::v1::Fea& ins_key() const;
  ::hashdb::v1::Fea* release_ins_key();
  ::hashdb::v1::Fea* mutable_ins_key();
  void set_allocated_ins_key(::hashdb::v1::Fea* ins_key);
  private:
  const ::hashdb::v1::Fea& _internal_ins_key() const;
  ::hashdb::v1::Fea* _internal_mutable_ins_key();
  public:
  void unsafe_arena_set_allocated_ins_key(
      ::hashdb::v1::Fea* ins_key);
  ::hashdb::v1::Fea* unsafe_arena_release_ins_key();

  // .hashdb.v1.ResultCode result = 13;
  bool has_result() const;
  private:
  bool _internal_has_result() const;
  public:
  void clear_result();
  const ::hashdb::v1::ResultCode& result() const;
  ::hashdb::v1::ResultCode* release_result();
  ::hashdb::v1::ResultCode* mutable_result();
  void set_allocated_result(::hashdb::v1::ResultCode* result);
  private:
  const ::hashdb::v1::ResultCode& _internal_result() const;
  ::hashdb::v1::ResultCode* _internal_mutable_result();
  public:
  void unsafe_arena_set_allocated_result(
      ::hashdb::v1::ResultCode* result);
  ::hashdb::v1::ResultCode* unsafe_arena_release_result();

  // uint64 proof_hash_counter = 11;
  void clear_proof_hash_counter();
  ::PROTOBUF_NAMESPACE_ID::uint64 proof_hash_counter() const;
  void set_proof_hash_counter(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_proof_hash_counter() const;
  void _internal_set_proof_hash_counter(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // bool is_old0 = 7;
  void clear_is_old0();
  bool is_old0() const;
  void set_is_old0(bool value);
  private:
  bool _internal_is_old0() const;
  void _internal_set_is_old0(bool value);
  public:

  // @@protoc_insertion_point(class_scope:hashdb.v1.SetResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::MapField<
      SetResponse_SiblingsEntry_DoNotUse,
      ::PROTOBUF_NAMESPACE_ID::uint64, ::hashdb::v1::SiblingList,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT64,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE,
      0 > siblings_;
  ::PROTOBUF_NAMESPACE_ID::internal::MapField<
      SetResponse_DbReadLogEntry_DoNotUse,
      std::string, ::hashdb::v1::FeList,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE,
      0 > db_read_log_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr ins_value_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr old_value_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr new_value_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr mode_;
  ::hashdb::v1::Fea* old_root_;
  ::hashdb::v1::Fea* new_root_;
  ::hashdb::v1::Fea* key_;
  ::hashdb::v1::Fea* ins_key_;
  ::hashdb::v1::ResultCode* result_;
  ::PROTOBUF_NAMESPACE_ID::uint64 proof_hash_counter_;
  bool is_old0_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_hashdb_2eproto;
};
// -------------------------------------------------------------------

class GetResponse_SiblingsEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<GetResponse_SiblingsEntry_DoNotUse, 
    ::PROTOBUF_NAMESPACE_ID::uint64, ::hashdb::v1::SiblingList,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT64,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE,
    0 > {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<GetResponse_SiblingsEntry_DoNotUse, 
    ::PROTOBUF_NAMESPACE_ID::uint64, ::hashdb::v1::SiblingList,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT64,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE,
    0 > SuperType;
  GetResponse_SiblingsEntry_DoNotUse();
  GetResponse_SiblingsEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const GetResponse_SiblingsEntry_DoNotUse& other);
  static const GetResponse_SiblingsEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const GetResponse_SiblingsEntry_DoNotUse*>(&_GetResponse_SiblingsEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(void*) { return true; }
  static bool ValidateValue(void*) { return true; }
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& other) final;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_hashdb_2eproto);
    return ::descriptor_table_hashdb_2eproto.file_level_metadata[15];
  }

  public:
};

// -------------------------------------------------------------------

class GetResponse_DbReadLogEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<GetResponse_DbReadLogEntry_DoNotUse, 
    std::string, ::hashdb::v1::FeList,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE,
    0 > {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<GetResponse_DbReadLogEntry_DoNotUse, 
    std::string, ::hashdb::v1::FeList,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE,
    0 > SuperType;
  GetResponse_DbReadLogEntry_DoNotUse();
  GetResponse_DbReadLogEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const GetResponse_DbReadLogEntry_DoNotUse& other);
  static const GetResponse_DbReadLogEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const GetResponse_DbReadLogEntry_DoNotUse*>(&_GetResponse_DbReadLogEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "hashdb.v1.GetResponse.DbReadLogEntry.key");
 }
  static bool ValidateValue(void*) { return true; }
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& other) final;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_hashdb_2eproto);
    return ::descriptor_table_hashdb_2eproto.file_level_metadata[16];
  }

  public:
};

// -------------------------------------------------------------------

class GetResponse PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:hashdb.v1.GetResponse) */ {
 public:
  inline GetResponse() : GetResponse(nullptr) {};
  virtual ~GetResponse();

  GetResponse(const GetResponse& from);
  GetResponse(GetResponse&& from) noexcept
    : GetResponse() {
    *this = ::std::move(from);
  }

  inline GetResponse& operator=(const GetResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetResponse& operator=(GetResponse&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const GetResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const GetResponse* internal_default_instance() {
    return reinterpret_cast<const GetResponse*>(
               &_GetResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    17;

  friend void swap(GetResponse& a, GetResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(GetResponse* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline GetResponse* New() const final {
    return CreateMaybeMessage<GetResponse>(nullptr);
  }

  GetResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<GetResponse>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const GetResponse& from);
  void MergeFrom(const GetResponse& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "hashdb.v1.GetResponse";
  }
  protected:
  explicit GetResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_hashdb_2eproto);
    return ::descriptor_table_hashdb_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  enum : int {
    kSiblingsFieldNumber = 3,
    kDbReadLogFieldNumber = 9,
    kInsValueFieldNumber = 5,
    kValueFieldNumber = 7,
    kRootFieldNumber = 1,
    kKeyFieldNumber = 2,
    kInsKeyFieldNumber = 4,
    kResultFieldNumber = 10,
    kProofHashCounterFieldNumber = 8,
    kIsOld0FieldNumber = 6,
  };
  // map<uint64, .hashdb.v1.SiblingList> siblings = 3;
  int siblings_size() const;
  private:
  int _internal_siblings_size() const;
  public:
  void clear_siblings();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< ::PROTOBUF_NAMESPACE_ID::uint64, ::hashdb::v1::SiblingList >&
      _internal_siblings() const;
  ::PROTOBUF_NAMESPACE_ID::Map< ::PROTOBUF_NAMESPACE_ID::uint64, ::hashdb::v1::SiblingList >*
      _internal_mutable_siblings();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< ::PROTOBUF_NAMESPACE_ID::uint64, ::hashdb::v1::SiblingList >&
      siblings() const;
  ::PROTOBUF_NAMESPACE_ID::Map< ::PROTOBUF_NAMESPACE_ID::uint64, ::hashdb::v1::SiblingList >*
      mutable_siblings();

  // map<string, .hashdb.v1.FeList> db_read_log = 9;
  int db_read_log_size() const;
  private:
  int _internal_db_read_log_size() const;
  public:
  void clear_db_read_log();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::hashdb::v1::FeList >&
      _internal_db_read_log() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::hashdb::v1::FeList >*
      _internal_mutable_db_read_log();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::hashdb::v1::FeList >&
      db_read_log() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::hashdb::v1::FeList >*
      mutable_db_read_log();

  // string ins_value = 5;
  void clear_ins_value();
  const std::string& ins_value() const;
  void set_ins_value(const std::string& value);
  void set_ins_value(std::string&& value);
  void set_ins_value(const char* value);
  void set_ins_value(const char* value, size_t size);
  std::string* mutable_ins_value();
  std::string* release_ins_value();
  void set_allocated_ins_value(std::string* ins_value);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_ins_value();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_ins_value(
      std::string* ins_value);
  private:
  const std::string& _internal_ins_value() const;
  void _internal_set_ins_value(const std::string& value);
  std::string* _internal_mutable_ins_value();
  public:

  // string value = 7;
  void clear_value();
  const std::string& value() const;
  void set_value(const std::string& value);
  void set_value(std::string&& value);
  void set_value(const char* value);
  void set_value(const char* value, size_t size);
  std::string* mutable_value();
  std::string* release_value();
  void set_allocated_value(std::string* value);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_value();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_value(
      std::string* value);
  private:
  const std::string& _internal_value() const;
  void _internal_set_value(const std::string& value);
  std::string* _internal_mutable_value();
  public:

  // .hashdb.v1.Fea root = 1;
  bool has_root() const;
  private:
  bool _internal_has_root() const;
  public:
  void clear_root();
  const ::hashdb::v1::Fea& root() const;
  ::hashdb::v1::Fea* release_root();
  ::hashdb::v1::Fea* mutable_root();
  void set_allocated_root(::hashdb::v1::Fea* root);
  private:
  const ::hashdb::v1::Fea& _internal_root() const;
  ::hashdb::v1::Fea* _internal_mutable_root();
  public:
  void unsafe_arena_set_allocated_root(
      ::hashdb::v1::Fea* root);
  ::hashdb::v1::Fea* unsafe_arena_release_root();

  // .hashdb.v1.Fea key = 2;
  bool has_key() const;
  private:
  bool _internal_has_key() const;
  public:
  void clear_key();
  const ::hashdb::v1::Fea& key() const;
  ::hashdb::v1::Fea* release_key();
  ::hashdb::v1::Fea* mutable_key();
  void set_allocated_key(::hashdb::v1::Fea* key);
  private:
  const ::hashdb::v1::Fea& _internal_key() const;
  ::hashdb::v1::Fea* _internal_mutable_key();
  public:
  void unsafe_arena_set_allocated_key(
      ::hashdb::v1::Fea* key);
  ::hashdb::v1::Fea* unsafe_arena_release_key();

  // .hashdb.v1.Fea ins_key = 4;
  bool has_ins_key() const;
  private:
  bool _internal_has_ins_key() const;
  public:
  void clear_ins_key();
  const ::hashdb::v1::Fea& ins_key() const;
  ::hashdb::v1::Fea* release_ins_key();
  ::hashdb::v1::Fea* mutable_ins_key();
  void set_allocated_ins_key(::hashdb::v1::Fea* ins_key);
  private:
  const ::hashdb::v1::Fea& _internal_ins_key() const;
  ::hashdb::v1::Fea* _internal_mutable_ins_key();
  public:
  void unsafe_arena_set_allocated_ins_key(
      ::hashdb::v1::Fea* ins_key);
  ::hashdb::v1::Fea* unsafe_arena_release_ins_key();

  // .hashdb.v1.ResultCode result = 10;
  bool has_result() const;
  private:
  bool _internal_has_result() const;
  public:
  void clear_result();
  const ::hashdb::v1::ResultCode& result() const;
  ::hashdb::v1::ResultCode* release_result();
  ::hashdb::v1::ResultCode* mutable_result();
  void set_allocated_result(::hashdb::v1::ResultCode* result);
  private:
  const ::hashdb::v1::ResultCode& _internal_result() const;
  ::hashdb::v1::ResultCode* _internal_mutable_result();
  public:
  void unsafe_arena_set_allocated_result(
      ::hashdb::v1::ResultCode* result);
  ::hashdb::v1::ResultCode* unsafe_arena_release_result();

  // uint64 proof_hash_counter = 8;
  void clear_proof_hash_counter();
  ::PROTOBUF_NAMESPACE_ID::uint64 proof_hash_counter() const;
  void set_proof_hash_counter(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_proof_hash_counter() const;
  void _internal_set_proof_hash_counter(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // bool is_old0 = 6;
  void clear_is_old0();
  bool is_old0() const;
  void set_is_old0(bool value);
  private:
  bool _internal_is_old0() const;
  void _internal_set_is_old0(bool value);
  public:

  // @@protoc_insertion_point(class_scope:hashdb.v1.GetResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::MapField<
      GetResponse_SiblingsEntry_DoNotUse,
      ::PROTOBUF_NAMESPACE_ID::uint64, ::hashdb::v1::SiblingList,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT64,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE,
      0 > siblings_;
  ::PROTOBUF_NAMESPACE_ID::internal::MapField<
      GetResponse_DbReadLogEntry_DoNotUse,
      std::string, ::hashdb::v1::FeList,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE,
      0 > db_read_log_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr ins_value_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr value_;
  ::hashdb::v1::Fea* root_;
  ::hashdb::v1::Fea* key_;
  ::hashdb::v1::Fea* ins_key_;
  ::hashdb::v1::ResultCode* result_;
  ::PROTOBUF_NAMESPACE_ID::uint64 proof_hash_counter_;
  bool is_old0_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_hashdb_2eproto;
};
// -------------------------------------------------------------------

class SetProgramResponse PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:hashdb.v1.SetProgramResponse) */ {
 public:
  inline SetProgramResponse() : SetProgramResponse(nullptr) {};
  virtual ~SetProgramResponse();

  SetProgramResponse(const SetProgramResponse& from);
  SetProgramResponse(SetProgramResponse&& from) noexcept
    : SetProgramResponse() {
    *this = ::std::move(from);
  }

  inline SetProgramResponse& operator=(const SetProgramResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline SetProgramResponse& operator=(SetProgramResponse&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const SetProgramResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SetProgramResponse* internal_default_instance() {
    return reinterpret_cast<const SetProgramResponse*>(
               &_SetProgramResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    18;

  friend void swap(SetProgramResponse& a, SetProgramResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(SetProgramResponse* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SetProgramResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline SetProgramResponse* New() const final {
    return CreateMaybeMessage<SetProgramResponse>(nullptr);
  }

  SetProgramResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<SetProgramResponse>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const SetProgramResponse& from);
  void MergeFrom(const SetProgramResponse& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SetProgramResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "hashdb.v1.SetProgramResponse";
  }
  protected:
  explicit SetProgramResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_hashdb_2eproto);
    return ::descriptor_table_hashdb_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kResultFieldNumber = 1,
  };
  // .hashdb.v1.ResultCode result = 1;
  bool has_result() const;
  private:
  bool _internal_has_result() const;
  public:
  void clear_result();
  const ::hashdb::v1::ResultCode& result() const;
  ::hashdb::v1::ResultCode* release_result();
  ::hashdb::v1::ResultCode* mutable_result();
  void set_allocated_result(::hashdb::v1::ResultCode* result);
  private:
  const ::hashdb::v1::ResultCode& _internal_result() const;
  ::hashdb::v1::ResultCode* _internal_mutable_result();
  public:
  void unsafe_arena_set_allocated_result(
      ::hashdb::v1::ResultCode* result);
  ::hashdb::v1::ResultCode* unsafe_arena_release_result();

  // @@protoc_insertion_point(class_scope:hashdb.v1.SetProgramResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::hashdb::v1::ResultCode* result_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_hashdb_2eproto;
};
// -------------------------------------------------------------------

class GetProgramResponse PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:hashdb.v1.GetProgramResponse) */ {
 public:
  inline GetProgramResponse() : GetProgramResponse(nullptr) {};
  virtual ~GetProgramResponse();

  GetProgramResponse(const GetProgramResponse& from);
  GetProgramResponse(GetProgramResponse&& from) noexcept
    : GetProgramResponse() {
    *this = ::std::move(from);
  }

  inline GetProgramResponse& operator=(const GetProgramResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetProgramResponse& operator=(GetProgramResponse&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const GetProgramResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const GetProgramResponse* internal_default_instance() {
    return reinterpret_cast<const GetProgramResponse*>(
               &_GetProgramResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    19;

  friend void swap(GetProgramResponse& a, GetProgramResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(GetProgramResponse* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetProgramResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline GetProgramResponse* New() const final {
    return CreateMaybeMessage<GetProgramResponse>(nullptr);
  }

  GetProgramResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<GetProgramResponse>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const GetProgramResponse& from);
  void MergeFrom(const GetProgramResponse& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetProgramResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "hashdb.v1.GetProgramResponse";
  }
  protected:
  explicit GetProgramResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_hashdb_2eproto);
    return ::descriptor_table_hashdb_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDataFieldNumber = 1,
    kResultFieldNumber = 2,
  };
  // bytes data = 1;
  void clear_data();
  const std::string& data() const;
  void set_data(const std::string& value);
  void set_data(std::string&& value);
  void set_data(const char* value);
  void set_data(const void* value, size_t size);
  std::string* mutable_data();
  std::string* release_data();
  void set_allocated_data(std::string* data);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_data();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_data(
      std::string* data);
  private:
  const std::string& _internal_data() const;
  void _internal_set_data(const std::string& value);
  std::string* _internal_mutable_data();
  public:

  // .hashdb.v1.ResultCode result = 2;
  bool has_result() const;
  private:
  bool _internal_has_result() const;
  public:
  void clear_result();
  const ::hashdb::v1::ResultCode& result() const;
  ::hashdb::v1::ResultCode* release_result();
  ::hashdb::v1::ResultCode* mutable_result();
  void set_allocated_result(::hashdb::v1::ResultCode* result);
  private:
  const ::hashdb::v1::ResultCode& _internal_result() const;
  ::hashdb::v1::ResultCode* _internal_mutable_result();
  public:
  void unsafe_arena_set_allocated_result(
      ::hashdb::v1::ResultCode* result);
  ::hashdb::v1::ResultCode* unsafe_arena_release_result();

  // @@protoc_insertion_point(class_scope:hashdb.v1.GetProgramResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr data_;
  ::hashdb::v1::ResultCode* result_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_hashdb_2eproto;
};
// -------------------------------------------------------------------

class FlushResponse PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:hashdb.v1.FlushResponse) */ {
 public:
  inline FlushResponse() : FlushResponse(nullptr) {};
  virtual ~FlushResponse();

  FlushResponse(const FlushResponse& from);
  FlushResponse(FlushResponse&& from) noexcept
    : FlushResponse() {
    *this = ::std::move(from);
  }

  inline FlushResponse& operator=(const FlushResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline FlushResponse& operator=(FlushResponse&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const FlushResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const FlushResponse* internal_default_instance() {
    return reinterpret_cast<const FlushResponse*>(
               &_FlushResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    20;

  friend void swap(FlushResponse& a, FlushResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(FlushResponse* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FlushResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline FlushResponse* New() const final {
    return CreateMaybeMessage<FlushResponse>(nullptr);
  }

  FlushResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<FlushResponse>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const FlushResponse& from);
  void MergeFrom(const FlushResponse& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FlushResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "hashdb.v1.FlushResponse";
  }
  protected:
  explicit FlushResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_hashdb_2eproto);
    return ::descriptor_table_hashdb_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kResultFieldNumber = 3,
    kFlushIdFieldNumber = 1,
    kStoredFlushIdFieldNumber = 2,
  };
  // .hashdb.v1.ResultCode result = 3;
  bool has_result() const;
  private:
  bool _internal_has_result() const;
  public:
  void clear_result();
  const ::hashdb::v1::ResultCode& result() const;
  ::hashdb::v1::ResultCode* release_result();
  ::hashdb::v1::ResultCode* mutable_result();
  void set_allocated_result(::hashdb::v1::ResultCode* result);
  private:
  const ::hashdb::v1::ResultCode& _internal_result() const;
  ::hashdb::v1::ResultCode* _internal_mutable_result();
  public:
  void unsafe_arena_set_allocated_result(
      ::hashdb::v1::ResultCode* result);
  ::hashdb::v1::ResultCode* unsafe_arena_release_result();

  // uint64 flush_id = 1;
  void clear_flush_id();
  ::PROTOBUF_NAMESPACE_ID::uint64 flush_id() const;
  void set_flush_id(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_flush_id() const;
  void _internal_set_flush_id(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // uint64 stored_flush_id = 2;
  void clear_stored_flush_id();
  ::PROTOBUF_NAMESPACE_ID::uint64 stored_flush_id() const;
  void set_stored_flush_id(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_stored_flush_id() const;
  void _internal_set_stored_flush_id(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // @@protoc_insertion_point(class_scope:hashdb.v1.FlushResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::hashdb::v1::ResultCode* result_;
  ::PROTOBUF_NAMESPACE_ID::uint64 flush_id_;
  ::PROTOBUF_NAMESPACE_ID::uint64 stored_flush_id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_hashdb_2eproto;
};
// -------------------------------------------------------------------

class GetFlushStatusResponse PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:hashdb.v1.GetFlushStatusResponse) */ {
 public:
  inline GetFlushStatusResponse() : GetFlushStatusResponse(nullptr) {};
  virtual ~GetFlushStatusResponse();

  GetFlushStatusResponse(const GetFlushStatusResponse& from);
  GetFlushStatusResponse(GetFlushStatusResponse&& from) noexcept
    : GetFlushStatusResponse() {
    *this = ::std::move(from);
  }

  inline GetFlushStatusResponse& operator=(const GetFlushStatusResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetFlushStatusResponse& operator=(GetFlushStatusResponse&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const GetFlushStatusResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const GetFlushStatusResponse* internal_default_instance() {
    return reinterpret_cast<const GetFlushStatusResponse*>(
               &_GetFlushStatusResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    21;

  friend void swap(GetFlushStatusResponse& a, GetFlushStatusResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(GetFlushStatusResponse* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetFlushStatusResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline GetFlushStatusResponse* New() const final {
    return CreateMaybeMessage<GetFlushStatusResponse>(nullptr);
  }

  GetFlushStatusResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<GetFlushStatusResponse>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const GetFlushStatusResponse& from);
  void MergeFrom(const GetFlushStatusResponse& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetFlushStatusResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "hashdb.v1.GetFlushStatusResponse";
  }
  protected:
  explicit GetFlushStatusResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_hashdb_2eproto);
    return ::descriptor_table_hashdb_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kProverIdFieldNumber = 8,
    kStoredFlushIdFieldNumber = 1,
    kStoringFlushIdFieldNumber = 2,
    kLastFlushIdFieldNumber = 3,
    kPendingToFlushNodesFieldNumber = 4,
    kPendingToFlushProgramFieldNumber = 5,
    kStoringNodesFieldNumber = 6,
    kStoringProgramFieldNumber = 7,
  };
  // string prover_id = 8;
  void clear_prover_id();
  const std::string& prover_id() const;
  void set_prover_id(const std::string& value);
  void set_prover_id(std::string&& value);
  void set_prover_id(const char* value);
  void set_prover_id(const char* value, size_t size);
  std::string* mutable_prover_id();
  std::string* release_prover_id();
  void set_allocated_prover_id(std::string* prover_id);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_prover_id();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_prover_id(
      std::string* prover_id);
  private:
  const std::string& _internal_prover_id() const;
  void _internal_set_prover_id(const std::string& value);
  std::string* _internal_mutable_prover_id();
  public:

  // uint64 stored_flush_id = 1;
  void clear_stored_flush_id();
  ::PROTOBUF_NAMESPACE_ID::uint64 stored_flush_id() const;
  void set_stored_flush_id(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_stored_flush_id() const;
  void _internal_set_stored_flush_id(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // uint64 storing_flush_id = 2;
  void clear_storing_flush_id();
  ::PROTOBUF_NAMESPACE_ID::uint64 storing_flush_id() const;
  void set_storing_flush_id(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_storing_flush_id() const;
  void _internal_set_storing_flush_id(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // uint64 last_flush_id = 3;
  void clear_last_flush_id();
  ::PROTOBUF_NAMESPACE_ID::uint64 last_flush_id() const;
  void set_last_flush_id(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_last_flush_id() const;
  void _internal_set_last_flush_id(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // uint64 pending_to_flush_nodes = 4;
  void clear_pending_to_flush_nodes();
  ::PROTOBUF_NAMESPACE_ID::uint64 pending_to_flush_nodes() const;
  void set_pending_to_flush_nodes(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_pending_to_flush_nodes() const;
  void _internal_set_pending_to_flush_nodes(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // uint64 pending_to_flush_program = 5;
  void clear_pending_to_flush_program();
  ::PROTOBUF_NAMESPACE_ID::uint64 pending_to_flush_program() const;
  void set_pending_to_flush_program(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_pending_to_flush_program() const;
  void _internal_set_pending_to_flush_program(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // uint64 storing_nodes = 6;
  void clear_storing_nodes();
  ::PROTOBUF_NAMESPACE_ID::uint64 storing_nodes() const;
  void set_storing_nodes(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_storing_nodes() const;
  void _internal_set_storing_nodes(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // uint64 storing_program = 7;
  void clear_storing_program();
  ::PROTOBUF_NAMESPACE_ID::uint64 storing_program() const;
  void set_storing_program(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_storing_program() const;
  void _internal_set_storing_program(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // @@protoc_insertion_point(class_scope:hashdb.v1.GetFlushStatusResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr prover_id_;
  ::PROTOBUF_NAMESPACE_ID::uint64 stored_flush_id_;
  ::PROTOBUF_NAMESPACE_ID::uint64 storing_flush_id_;
  ::PROTOBUF_NAMESPACE_ID::uint64 last_flush_id_;
  ::PROTOBUF_NAMESPACE_ID::uint64 pending_to_flush_nodes_;
  ::PROTOBUF_NAMESPACE_ID::uint64 pending_to_flush_program_;
  ::PROTOBUF_NAMESPACE_ID::uint64 storing_nodes_;
  ::PROTOBUF_NAMESPACE_ID::uint64 storing_program_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_hashdb_2eproto;
};
// -------------------------------------------------------------------

class GetFlushDataResponse_NodesEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<GetFlushDataResponse_NodesEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    0 > {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<GetFlushDataResponse_NodesEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    0 > SuperType;
  GetFlushDataResponse_NodesEntry_DoNotUse();
  GetFlushDataResponse_NodesEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const GetFlushDataResponse_NodesEntry_DoNotUse& other);
  static const GetFlushDataResponse_NodesEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const GetFlushDataResponse_NodesEntry_DoNotUse*>(&_GetFlushDataResponse_NodesEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "hashdb.v1.GetFlushDataResponse.NodesEntry.key");
 }
  static bool ValidateValue(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "hashdb.v1.GetFlushDataResponse.NodesEntry.value");
 }
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& other) final;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_hashdb_2eproto);
    return ::descriptor_table_hashdb_2eproto.file_level_metadata[22];
  }

  public:
};

// -------------------------------------------------------------------

class GetFlushDataResponse_ProgramEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<GetFlushDataResponse_ProgramEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    0 > {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<GetFlushDataResponse_ProgramEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    0 > SuperType;
  GetFlushDataResponse_ProgramEntry_DoNotUse();
  GetFlushDataResponse_ProgramEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const GetFlushDataResponse_ProgramEntry_DoNotUse& other);
  static const GetFlushDataResponse_ProgramEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const GetFlushDataResponse_ProgramEntry_DoNotUse*>(&_GetFlushDataResponse_ProgramEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "hashdb.v1.GetFlushDataResponse.ProgramEntry.key");
 }
  static bool ValidateValue(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "hashdb.v1.GetFlushDataResponse.ProgramEntry.value");
 }
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& other) final;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_hashdb_2eproto);
    return ::descriptor_table_hashdb_2eproto.file_level_metadata[23];
  }

  public:
};

// -------------------------------------------------------------------

class GetFlushDataResponse PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:hashdb.v1.GetFlushDataResponse) */ {
 public:
  inline GetFlushDataResponse() : GetFlushDataResponse(nullptr) {};
  virtual ~GetFlushDataResponse();

  GetFlushDataResponse(const GetFlushDataResponse& from);
  GetFlushDataResponse(GetFlushDataResponse&& from) noexcept
    : GetFlushDataResponse() {
    *this = ::std::move(from);
  }

  inline GetFlushDataResponse& operator=(const GetFlushDataResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetFlushDataResponse& operator=(GetFlushDataResponse&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const GetFlushDataResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const GetFlushDataResponse* internal_default_instance() {
    return reinterpret_cast<const GetFlushDataResponse*>(
               &_GetFlushDataResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    24;

  friend void swap(GetFlushDataResponse& a, GetFlushDataResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(GetFlushDataResponse* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetFlushDataResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline GetFlushDataResponse* New() const final {
    return CreateMaybeMessage<GetFlushDataResponse>(nullptr);
  }

  GetFlushDataResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<GetFlushDataResponse>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const GetFlushDataResponse& from);
  void MergeFrom(const GetFlushDataResponse& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetFlushDataResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "hashdb.v1.GetFlushDataResponse";
  }
  protected:
  explicit GetFlushDataResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_hashdb_2eproto);
    return ::descriptor_table_hashdb_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  enum : int {
    kNodesFieldNumber = 2,
    kProgramFieldNumber = 3,
    kNodesStateRootFieldNumber = 4,
    kResultFieldNumber = 5,
    kStoredFlushIdFieldNumber = 1,
  };
  // map<string, string> nodes = 2;
  int nodes_size() const;
  private:
  int _internal_nodes_size() const;
  public:
  void clear_nodes();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      _internal_nodes() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      _internal_mutable_nodes();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      nodes() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      mutable_nodes();

  // map<string, string> program = 3;
  int program_size() const;
  private:
  int _internal_program_size() const;
  public:
  void clear_program();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      _internal_program() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      _internal_mutable_program();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      program() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      mutable_program();

  // string nodes_state_root = 4;
  void clear_nodes_state_root();
  const std::string& nodes_state_root() const;
  void set_nodes_state_root(const std::string& value);
  void set_nodes_state_root(std::string&& value);
  void set_nodes_state_root(const char* value);
  void set_nodes_state_root(const char* value, size_t size);
  std::string* mutable_nodes_state_root();
  std::string* release_nodes_state_root();
  void set_allocated_nodes_state_root(std::string* nodes_state_root);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_nodes_state_root();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_nodes_state_root(
      std::string* nodes_state_root);
  private:
  const std::string& _internal_nodes_state_root() const;
  void _internal_set_nodes_state_root(const std::string& value);
  std::string* _internal_mutable_nodes_state_root();
  public:

  // .hashdb.v1.ResultCode result = 5;
  bool has_result() const;
  private:
  bool _internal_has_result() const;
  public:
  void clear_result();
  const ::hashdb::v1::ResultCode& result() const;
  ::hashdb::v1::ResultCode* release_result();
  ::hashdb::v1::ResultCode* mutable_result();
  void set_allocated_result(::hashdb::v1::ResultCode* result);
  private:
  const ::hashdb::v1::ResultCode& _internal_result() const;
  ::hashdb::v1::ResultCode* _internal_mutable_result();
  public:
  void unsafe_arena_set_allocated_result(
      ::hashdb::v1::ResultCode* result);
  ::hashdb::v1::ResultCode* unsafe_arena_release_result();

  // uint64 stored_flush_id = 1;
  void clear_stored_flush_id();
  ::PROTOBUF_NAMESPACE_ID::uint64 stored_flush_id() const;
  void set_stored_flush_id(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_stored_flush_id() const;
  void _internal_set_stored_flush_id(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // @@protoc_insertion_point(class_scope:hashdb.v1.GetFlushDataResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::MapField<
      GetFlushDataResponse_NodesEntry_DoNotUse,
      std::string, std::string,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
      0 > nodes_;
  ::PROTOBUF_NAMESPACE_ID::internal::MapField<
      GetFlushDataResponse_ProgramEntry_DoNotUse,
      std::string, std::string,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
      0 > program_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr nodes_state_root_;
  ::hashdb::v1::ResultCode* result_;
  ::PROTOBUF_NAMESPACE_ID::uint64 stored_flush_id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_hashdb_2eproto;
};
// -------------------------------------------------------------------

class Fea PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:hashdb.v1.Fea) */ {
 public:
  inline Fea() : Fea(nullptr) {};
  virtual ~Fea();

  Fea(const Fea& from);
  Fea(Fea&& from) noexcept
    : Fea() {
    *this = ::std::move(from);
  }

  inline Fea& operator=(const Fea& from) {
    CopyFrom(from);
    return *this;
  }
  inline Fea& operator=(Fea&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Fea& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Fea* internal_default_instance() {
    return reinterpret_cast<const Fea*>(
               &_Fea_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    25;

  friend void swap(Fea& a, Fea& b) {
    a.Swap(&b);
  }
  inline void Swap(Fea* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Fea* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Fea* New() const final {
    return CreateMaybeMessage<Fea>(nullptr);
  }

  Fea* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Fea>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Fea& from);
  void MergeFrom(const Fea& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Fea* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "hashdb.v1.Fea";
  }
  protected:
  explicit Fea(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_hashdb_2eproto);
    return ::descriptor_table_hashdb_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFe0FieldNumber = 1,
    kFe1FieldNumber = 2,
    kFe2FieldNumber = 3,
    kFe3FieldNumber = 4,
  };
  // uint64 fe0 = 1;
  void clear_fe0();
  ::PROTOBUF_NAMESPACE_ID::uint64 fe0() const;
  void set_fe0(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_fe0() const;
  void _internal_set_fe0(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // uint64 fe1 = 2;
  void clear_fe1();
  ::PROTOBUF_NAMESPACE_ID::uint64 fe1() const;
  void set_fe1(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_fe1() const;
  void _internal_set_fe1(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // uint64 fe2 = 3;
  void clear_fe2();
  ::PROTOBUF_NAMESPACE_ID::uint64 fe2() const;
  void set_fe2(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_fe2() const;
  void _internal_set_fe2(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // uint64 fe3 = 4;
  void clear_fe3();
  ::PROTOBUF_NAMESPACE_ID::uint64 fe3() const;
  void set_fe3(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_fe3() const;
  void _internal_set_fe3(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // @@protoc_insertion_point(class_scope:hashdb.v1.Fea)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::uint64 fe0_;
  ::PROTOBUF_NAMESPACE_ID::uint64 fe1_;
  ::PROTOBUF_NAMESPACE_ID::uint64 fe2_;
  ::PROTOBUF_NAMESPACE_ID::uint64 fe3_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_hashdb_2eproto;
};
// -------------------------------------------------------------------

class FeList PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:hashdb.v1.FeList) */ {
 public:
  inline FeList() : FeList(nullptr) {};
  virtual ~FeList();

  FeList(const FeList& from);
  FeList(FeList&& from) noexcept
    : FeList() {
    *this = ::std::move(from);
  }

  inline FeList& operator=(const FeList& from) {
    CopyFrom(from);
    return *this;
  }
  inline FeList& operator=(FeList&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const FeList& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const FeList* internal_default_instance() {
    return reinterpret_cast<const FeList*>(
               &_FeList_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    26;

  friend void swap(FeList& a, FeList& b) {
    a.Swap(&b);
  }
  inline void Swap(FeList* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FeList* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline FeList* New() const final {
    return CreateMaybeMessage<FeList>(nullptr);
  }

  FeList* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<FeList>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const FeList& from);
  void MergeFrom(const FeList& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FeList* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "hashdb.v1.FeList";
  }
  protected:
  explicit FeList(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_hashdb_2eproto);
    return ::descriptor_table_hashdb_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFeFieldNumber = 1,
  };
  // repeated uint64 fe = 1;
  int fe_size() const;
  private:
  int _internal_fe_size() const;
  public:
  void clear_fe();
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_fe(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::uint64 >&
      _internal_fe() const;
  void _internal_add_fe(::PROTOBUF_NAMESPACE_ID::uint64 value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::uint64 >*
      _internal_mutable_fe();
  public:
  ::PROTOBUF_NAMESPACE_ID::uint64 fe(int index) const;
  void set_fe(int index, ::PROTOBUF_NAMESPACE_ID::uint64 value);
  void add_fe(::PROTOBUF_NAMESPACE_ID::uint64 value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::uint64 >&
      fe() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::uint64 >*
      mutable_fe();

  // @@protoc_insertion_point(class_scope:hashdb.v1.FeList)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::uint64 > fe_;
  mutable std::atomic<int> _fe_cached_byte_size_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_hashdb_2eproto;
};
// -------------------------------------------------------------------

class SiblingList PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:hashdb.v1.SiblingList) */ {
 public:
  inline SiblingList() : SiblingList(nullptr) {};
  virtual ~SiblingList();

  SiblingList(const SiblingList& from);
  SiblingList(SiblingList&& from) noexcept
    : SiblingList() {
    *this = ::std::move(from);
  }

  inline SiblingList& operator=(const SiblingList& from) {
    CopyFrom(from);
    return *this;
  }
  inline SiblingList& operator=(SiblingList&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const SiblingList& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SiblingList* internal_default_instance() {
    return reinterpret_cast<const SiblingList*>(
               &_SiblingList_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    27;

  friend void swap(SiblingList& a, SiblingList& b) {
    a.Swap(&b);
  }
  inline void Swap(SiblingList* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SiblingList* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline SiblingList* New() const final {
    return CreateMaybeMessage<SiblingList>(nullptr);
  }

  SiblingList* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<SiblingList>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const SiblingList& from);
  void MergeFrom(const SiblingList& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SiblingList* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "hashdb.v1.SiblingList";
  }
  protected:
  explicit SiblingList(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_hashdb_2eproto);
    return ::descriptor_table_hashdb_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSiblingFieldNumber = 1,
  };
  // repeated uint64 sibling = 1;
  int sibling_size() const;
  private:
  int _internal_sibling_size() const;
  public:
  void clear_sibling();
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_sibling(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::uint64 >&
      _internal_sibling() const;
  void _internal_add_sibling(::PROTOBUF_NAMESPACE_ID::uint64 value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::uint64 >*
      _internal_mutable_sibling();
  public:
  ::PROTOBUF_NAMESPACE_ID::uint64 sibling(int index) const;
  void set_sibling(int index, ::PROTOBUF_NAMESPACE_ID::uint64 value);
  void add_sibling(::PROTOBUF_NAMESPACE_ID::uint64 value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::uint64 >&
      sibling() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::uint64 >*
      mutable_sibling();

  // @@protoc_insertion_point(class_scope:hashdb.v1.SiblingList)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::uint64 > sibling_;
  mutable std::atomic<int> _sibling_cached_byte_size_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_hashdb_2eproto;
};
// -------------------------------------------------------------------

class ResultCode PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:hashdb.v1.ResultCode) */ {
 public:
  inline ResultCode() : ResultCode(nullptr) {};
  virtual ~ResultCode();

  ResultCode(const ResultCode& from);
  ResultCode(ResultCode&& from) noexcept
    : ResultCode() {
    *this = ::std::move(from);
  }

  inline ResultCode& operator=(const ResultCode& from) {
    CopyFrom(from);
    return *this;
  }
  inline ResultCode& operator=(ResultCode&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const ResultCode& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ResultCode* internal_default_instance() {
    return reinterpret_cast<const ResultCode*>(
               &_ResultCode_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    28;

  friend void swap(ResultCode& a, ResultCode& b) {
    a.Swap(&b);
  }
  inline void Swap(ResultCode* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ResultCode* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ResultCode* New() const final {
    return CreateMaybeMessage<ResultCode>(nullptr);
  }

  ResultCode* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ResultCode>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ResultCode& from);
  void MergeFrom(const ResultCode& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ResultCode* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "hashdb.v1.ResultCode";
  }
  protected:
  explicit ResultCode(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_hashdb_2eproto);
    return ::descriptor_table_hashdb_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  typedef ResultCode_Code Code;
  static constexpr Code CODE_UNSPECIFIED =
    ResultCode_Code_CODE_UNSPECIFIED;
  static constexpr Code CODE_SUCCESS =
    ResultCode_Code_CODE_SUCCESS;
  static constexpr Code CODE_DB_KEY_NOT_FOUND =
    ResultCode_Code_CODE_DB_KEY_NOT_FOUND;
  static constexpr Code CODE_DB_ERROR =
    ResultCode_Code_CODE_DB_ERROR;
  static constexpr Code CODE_INTERNAL_ERROR =
    ResultCode_Code_CODE_INTERNAL_ERROR;
  static constexpr Code CODE_SMT_INVALID_DATA_SIZE =
    ResultCode_Code_CODE_SMT_INVALID_DATA_SIZE;
  static inline bool Code_IsValid(int value) {
    return ResultCode_Code_IsValid(value);
  }
  static constexpr Code Code_MIN =
    ResultCode_Code_Code_MIN;
  static constexpr Code Code_MAX =
    ResultCode_Code_Code_MAX;
  static constexpr int Code_ARRAYSIZE =
    ResultCode_Code_Code_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  Code_descriptor() {
    return ResultCode_Code_descriptor();
  }
  template<typename T>
  static inline const std::string& Code_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Code>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Code_Name.");
    return ResultCode_Code_Name(enum_t_value);
  }
  static inline bool Code_Parse(const std::string& name,
      Code* value) {
    return ResultCode_Code_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kCodeFieldNumber = 1,
  };
  // .hashdb.v1.ResultCode.Code code = 1;
  void clear_code();
  ::hashdb::v1::ResultCode_Code code() const;
  void set_code(::hashdb::v1::ResultCode_Code value);
  private:
  ::hashdb::v1::ResultCode_Code _internal_code() const;
  void _internal_set_code(::hashdb::v1::ResultCode_Code value);
  public:

  // @@protoc_insertion_point(class_scope:hashdb.v1.ResultCode)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  int code_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_hashdb_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// Version

// string v0_0_1 = 1;
inline void Version::clear_v0_0_1() {
  v0_0_1_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& Version::v0_0_1() const {
  // @@protoc_insertion_point(field_get:hashdb.v1.Version.v0_0_1)
  return _internal_v0_0_1();
}
inline void Version::set_v0_0_1(const std::string& value) {
  _internal_set_v0_0_1(value);
  // @@protoc_insertion_point(field_set:hashdb.v1.Version.v0_0_1)
}
inline std::string* Version::mutable_v0_0_1() {
  // @@protoc_insertion_point(field_mutable:hashdb.v1.Version.v0_0_1)
  return _internal_mutable_v0_0_1();
}
inline const std::string& Version::_internal_v0_0_1() const {
  return v0_0_1_.Get();
}
inline void Version::_internal_set_v0_0_1(const std::string& value) {
  
  v0_0_1_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void Version::set_v0_0_1(std::string&& value) {
  
  v0_0_1_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:hashdb.v1.Version.v0_0_1)
}
inline void Version::set_v0_0_1(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  v0_0_1_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:hashdb.v1.Version.v0_0_1)
}
inline void Version::set_v0_0_1(const char* value,
    size_t size) {
  
  v0_0_1_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:hashdb.v1.Version.v0_0_1)
}
inline std::string* Version::_internal_mutable_v0_0_1() {
  
  return v0_0_1_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* Version::release_v0_0_1() {
  // @@protoc_insertion_point(field_release:hashdb.v1.Version.v0_0_1)
  return v0_0_1_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void Version::set_allocated_v0_0_1(std::string* v0_0_1) {
  if (v0_0_1 != nullptr) {
    
  } else {
    
  }
  v0_0_1_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), v0_0_1,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:hashdb.v1.Version.v0_0_1)
}
inline std::string* Version::unsafe_arena_release_v0_0_1() {
  // @@protoc_insertion_point(field_unsafe_arena_release:hashdb.v1.Version.v0_0_1)
  GOOGLE_DCHECK(GetArena() != nullptr);
  
  return v0_0_1_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void Version::unsafe_arena_set_allocated_v0_0_1(
    std::string* v0_0_1) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (v0_0_1 != nullptr) {
    
  } else {
    
  }
  v0_0_1_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      v0_0_1, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:hashdb.v1.Version.v0_0_1)
}

// -------------------------------------------------------------------

// SetRequest

// .hashdb.v1.Fea old_root = 1;
inline bool SetRequest::_internal_has_old_root() const {
  return this != internal_default_instance() && old_root_ != nullptr;
}
inline bool SetRequest::has_old_root() const {
  return _internal_has_old_root();
}
inline void SetRequest::clear_old_root() {
  if (GetArena() == nullptr && old_root_ != nullptr) {
    delete old_root_;
  }
  old_root_ = nullptr;
}
inline const ::hashdb::v1::Fea& SetRequest::_internal_old_root() const {
  const ::hashdb::v1::Fea* p = old_root_;
  return p != nullptr ? *p : *reinterpret_cast<const ::hashdb::v1::Fea*>(
      &::hashdb::v1::_Fea_default_instance_);
}
inline const ::hashdb::v1::Fea& SetRequest::old_root() const {
  // @@protoc_insertion_point(field_get:hashdb.v1.SetRequest.old_root)
  return _internal_old_root();
}
inline void SetRequest::unsafe_arena_set_allocated_old_root(
    ::hashdb::v1::Fea* old_root) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(old_root_);
  }
  old_root_ = old_root;
  if (old_root) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:hashdb.v1.SetRequest.old_root)
}
inline ::hashdb::v1::Fea* SetRequest::release_old_root() {
  auto temp = unsafe_arena_release_old_root();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::hashdb::v1::Fea* SetRequest::unsafe_arena_release_old_root() {
  // @@protoc_insertion_point(field_release:hashdb.v1.SetRequest.old_root)
  
  ::hashdb::v1::Fea* temp = old_root_;
  old_root_ = nullptr;
  return temp;
}
inline ::hashdb::v1::Fea* SetRequest::_internal_mutable_old_root() {
  
  if (old_root_ == nullptr) {
    auto* p = CreateMaybeMessage<::hashdb::v1::Fea>(GetArena());
    old_root_ = p;
  }
  return old_root_;
}
inline ::hashdb::v1::Fea* SetRequest::mutable_old_root() {
  // @@protoc_insertion_point(field_mutable:hashdb.v1.SetRequest.old_root)
  return _internal_mutable_old_root();
}
inline void SetRequest::set_allocated_old_root(::hashdb::v1::Fea* old_root) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete old_root_;
  }
  if (old_root) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(old_root);
    if (message_arena != submessage_arena) {
      old_root = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, old_root, submessage_arena);
    }
    
  } else {
    
  }
  old_root_ = old_root;
  // @@protoc_insertion_point(field_set_allocated:hashdb.v1.SetRequest.old_root)
}

// .hashdb.v1.Fea key = 2;
inline bool SetRequest::_internal_has_key() const {
  return this != internal_default_instance() && key_ != nullptr;
}
inline bool SetRequest::has_key() const {
  return _internal_has_key();
}
inline void SetRequest::clear_key() {
  if (GetArena() == nullptr && key_ != nullptr) {
    delete key_;
  }
  key_ = nullptr;
}
inline const ::hashdb::v1::Fea& SetRequest::_internal_key() const {
  const ::hashdb::v1::Fea* p = key_;
  return p != nullptr ? *p : *reinterpret_cast<const ::hashdb::v1::Fea*>(
      &::hashdb::v1::_Fea_default_instance_);
}
inline const ::hashdb::v1::Fea& SetRequest::key() const {
  // @@protoc_insertion_point(field_get:hashdb.v1.SetRequest.key)
  return _internal_key();
}
inline void SetRequest::unsafe_arena_set_allocated_key(
    ::hashdb::v1::Fea* key) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(key_);
  }
  key_ = key;
  if (key) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:hashdb.v1.SetRequest.key)
}
inline ::hashdb::v1::Fea* SetRequest::release_key() {
  auto temp = unsafe_arena_release_key();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::hashdb::v1::Fea* SetRequest::unsafe_arena_release_key() {
  // @@protoc_insertion_point(field_release:hashdb.v1.SetRequest.key)
  
  ::hashdb::v1::Fea* temp = key_;
  key_ = nullptr;
  return temp;
}
inline ::hashdb::v1::Fea* SetRequest::_internal_mutable_key() {
  
  if (key_ == nullptr) {
    auto* p = CreateMaybeMessage<::hashdb::v1::Fea>(GetArena());
    key_ = p;
  }
  return key_;
}
inline ::hashdb::v1::Fea* SetRequest::mutable_key() {
  // @@protoc_insertion_point(field_mutable:hashdb.v1.SetRequest.key)
  return _internal_mutable_key();
}
inline void SetRequest::set_allocated_key(::hashdb::v1::Fea* key) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete key_;
  }
  if (key) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(key);
    if (message_arena != submessage_arena) {
      key = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, key, submessage_arena);
    }
    
  } else {
    
  }
  key_ = key;
  // @@protoc_insertion_point(field_set_allocated:hashdb.v1.SetRequest.key)
}

// string value = 3;
inline void SetRequest::clear_value() {
  value_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& SetRequest::value() const {
  // @@protoc_insertion_point(field_get:hashdb.v1.SetRequest.value)
  return _internal_value();
}
inline void SetRequest::set_value(const std::string& value) {
  _internal_set_value(value);
  // @@protoc_insertion_point(field_set:hashdb.v1.SetRequest.value)
}
inline std::string* SetRequest::mutable_value() {
  // @@protoc_insertion_point(field_mutable:hashdb.v1.SetRequest.value)
  return _internal_mutable_value();
}
inline const std::string& SetRequest::_internal_value() const {
  return value_.Get();
}
inline void SetRequest::_internal_set_value(const std::string& value) {
  
  value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void SetRequest::set_value(std::string&& value) {
  
  value_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:hashdb.v1.SetRequest.value)
}
inline void SetRequest::set_value(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:hashdb.v1.SetRequest.value)
}
inline void SetRequest::set_value(const char* value,
    size_t size) {
  
  value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:hashdb.v1.SetRequest.value)
}
inline std::string* SetRequest::_internal_mutable_value() {
  
  return value_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* SetRequest::release_value() {
  // @@protoc_insertion_point(field_release:hashdb.v1.SetRequest.value)
  return value_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void SetRequest::set_allocated_value(std::string* value) {
  if (value != nullptr) {
    
  } else {
    
  }
  value_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:hashdb.v1.SetRequest.value)
}
inline std::string* SetRequest::unsafe_arena_release_value() {
  // @@protoc_insertion_point(field_unsafe_arena_release:hashdb.v1.SetRequest.value)
  GOOGLE_DCHECK(GetArena() != nullptr);
  
  return value_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void SetRequest::unsafe_arena_set_allocated_value(
    std::string* value) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (value != nullptr) {
    
  } else {
    
  }
  value_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      value, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:hashdb.v1.SetRequest.value)
}

// .hashdb.v1.Persistence persistence = 4;
inline void SetRequest::clear_persistence() {
  persistence_ = 0;
}
inline ::hashdb::v1::Persistence SetRequest::_internal_persistence() const {
  return static_cast< ::hashdb::v1::Persistence >(persistence_);
}
inline ::hashdb::v1::Persistence SetRequest::persistence() const {
  // @@protoc_insertion_point(field_get:hashdb.v1.SetRequest.persistence)
  return _internal_persistence();
}
inline void SetRequest::_internal_set_persistence(::hashdb::v1::Persistence value) {
  
  persistence_ = value;
}
inline void SetRequest::set_persistence(::hashdb::v1::Persistence value) {
  _internal_set_persistence(value);
  // @@protoc_insertion_point(field_set:hashdb.v1.SetRequest.persistence)
}

// bool details = 5;
inline void SetRequest::clear_details() {
  details_ = false;
}
inline bool SetRequest::_internal_details() const {
  return details_;
}
inline bool SetRequest::details() const {
  // @@protoc_insertion_point(field_get:hashdb.v1.SetRequest.details)
  return _internal_details();
}
inline void SetRequest::_internal_set_details(bool value) {
  
  details_ = value;
}
inline void SetRequest::set_details(bool value) {
  _internal_set_details(value);
  // @@protoc_insertion_point(field_set:hashdb.v1.SetRequest.details)
}

// bool get_db_read_log = 6;
inline void SetRequest::clear_get_db_read_log() {
  get_db_read_log_ = false;
}
inline bool SetRequest::_internal_get_db_read_log() const {
  return get_db_read_log_;
}
inline bool SetRequest::get_db_read_log() const {
  // @@protoc_insertion_point(field_get:hashdb.v1.SetRequest.get_db_read_log)
  return _internal_get_db_read_log();
}
inline void SetRequest::_internal_set_get_db_read_log(bool value) {
  
  get_db_read_log_ = value;
}
inline void SetRequest::set_get_db_read_log(bool value) {
  _internal_set_get_db_read_log(value);
  // @@protoc_insertion_point(field_set:hashdb.v1.SetRequest.get_db_read_log)
}

// string batch_uuid = 7;
inline void SetRequest::clear_batch_uuid() {
  batch_uuid_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& SetRequest::batch_uuid() const {
  // @@protoc_insertion_point(field_get:hashdb.v1.SetRequest.batch_uuid)
  return _internal_batch_uuid();
}
inline void SetRequest::set_batch_uuid(const std::string& value) {
  _internal_set_batch_uuid(value);
  // @@protoc_insertion_point(field_set:hashdb.v1.SetRequest.batch_uuid)
}
inline std::string* SetRequest::mutable_batch_uuid() {
  // @@protoc_insertion_point(field_mutable:hashdb.v1.SetRequest.batch_uuid)
  return _internal_mutable_batch_uuid();
}
inline const std::string& SetRequest::_internal_batch_uuid() const {
  return batch_uuid_.Get();
}
inline void SetRequest::_internal_set_batch_uuid(const std::string& value) {
  
  batch_uuid_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void SetRequest::set_batch_uuid(std::string&& value) {
  
  batch_uuid_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:hashdb.v1.SetRequest.batch_uuid)
}
inline void SetRequest::set_batch_uuid(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  batch_uuid_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:hashdb.v1.SetRequest.batch_uuid)
}
inline void SetRequest::set_batch_uuid(const char* value,
    size_t size) {
  
  batch_uuid_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:hashdb.v1.SetRequest.batch_uuid)
}
inline std::string* SetRequest::_internal_mutable_batch_uuid() {
  
  return batch_uuid_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* SetRequest::release_batch_uuid() {
  // @@protoc_insertion_point(field_release:hashdb.v1.SetRequest.batch_uuid)
  return batch_uuid_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void SetRequest::set_allocated_batch_uuid(std::string* batch_uuid) {
  if (batch_uuid != nullptr) {
    
  } else {
    
  }
  batch_uuid_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), batch_uuid,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:hashdb.v1.SetRequest.batch_uuid)
}
inline std::string* SetRequest::unsafe_arena_release_batch_uuid() {
  // @@protoc_insertion_point(field_unsafe_arena_release:hashdb.v1.SetRequest.batch_uuid)
  GOOGLE_DCHECK(GetArena() != nullptr);
  
  return batch_uuid_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void SetRequest::unsafe_arena_set_allocated_batch_uuid(
    std::string* batch_uuid) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (batch_uuid != nullptr) {
    
  } else {
    
  }
  batch_uuid_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      batch_uuid, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:hashdb.v1.SetRequest.batch_uuid)
}

// uint64 tx = 8;
inline void SetRequest::clear_tx() {
  tx_ = PROTOBUF_ULONGLONG(0);
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 SetRequest::_internal_tx() const {
  return tx_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 SetRequest::tx() const {
  // @@protoc_insertion_point(field_get:hashdb.v1.SetRequest.tx)
  return _internal_tx();
}
inline void SetRequest::_internal_set_tx(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  
  tx_ = value;
}
inline void SetRequest::set_tx(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_tx(value);
  // @@protoc_insertion_point(field_set:hashdb.v1.SetRequest.tx)
}

// -------------------------------------------------------------------

// GetRequest

// .hashdb.v1.Fea root = 1;
inline bool GetRequest::_internal_has_root() const {
  return this != internal_default_instance() && root_ != nullptr;
}
inline bool GetRequest::has_root() const {
  return _internal_has_root();
}
inline void GetRequest::clear_root() {
  if (GetArena() == nullptr && root_ != nullptr) {
    delete root_;
  }
  root_ = nullptr;
}
inline const ::hashdb::v1::Fea& GetRequest::_internal_root() const {
  const ::hashdb::v1::Fea* p = root_;
  return p != nullptr ? *p : *reinterpret_cast<const ::hashdb::v1::Fea*>(
      &::hashdb::v1::_Fea_default_instance_);
}
inline const ::hashdb::v1::Fea& GetRequest::root() const {
  // @@protoc_insertion_point(field_get:hashdb.v1.GetRequest.root)
  return _internal_root();
}
inline void GetRequest::unsafe_arena_set_allocated_root(
    ::hashdb::v1::Fea* root) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(root_);
  }
  root_ = root;
  if (root) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:hashdb.v1.GetRequest.root)
}
inline ::hashdb::v1::Fea* GetRequest::release_root() {
  auto temp = unsafe_arena_release_root();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::hashdb::v1::Fea* GetRequest::unsafe_arena_release_root() {
  // @@protoc_insertion_point(field_release:hashdb.v1.GetRequest.root)
  
  ::hashdb::v1::Fea* temp = root_;
  root_ = nullptr;
  return temp;
}
inline ::hashdb::v1::Fea* GetRequest::_internal_mutable_root() {
  
  if (root_ == nullptr) {
    auto* p = CreateMaybeMessage<::hashdb::v1::Fea>(GetArena());
    root_ = p;
  }
  return root_;
}
inline ::hashdb::v1::Fea* GetRequest::mutable_root() {
  // @@protoc_insertion_point(field_mutable:hashdb.v1.GetRequest.root)
  return _internal_mutable_root();
}
inline void GetRequest::set_allocated_root(::hashdb::v1::Fea* root) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete root_;
  }
  if (root) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(root);
    if (message_arena != submessage_arena) {
      root = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, root, submessage_arena);
    }
    
  } else {
    
  }
  root_ = root;
  // @@protoc_insertion_point(field_set_allocated:hashdb.v1.GetRequest.root)
}

// .hashdb.v1.Fea key = 2;
inline bool GetRequest::_internal_has_key() const {
  return this != internal_default_instance() && key_ != nullptr;
}
inline bool GetRequest::has_key() const {
  return _internal_has_key();
}
inline void GetRequest::clear_key() {
  if (GetArena() == nullptr && key_ != nullptr) {
    delete key_;
  }
  key_ = nullptr;
}
inline const ::hashdb::v1::Fea& GetRequest::_internal_key() const {
  const ::hashdb::v1::Fea* p = key_;
  return p != nullptr ? *p : *reinterpret_cast<const ::hashdb::v1::Fea*>(
      &::hashdb::v1::_Fea_default_instance_);
}
inline const ::hashdb::v1::Fea& GetRequest::key() const {
  // @@protoc_insertion_point(field_get:hashdb.v1.GetRequest.key)
  return _internal_key();
}
inline void GetRequest::unsafe_arena_set_allocated_key(
    ::hashdb::v1::Fea* key) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(key_);
  }
  key_ = key;
  if (key) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:hashdb.v1.GetRequest.key)
}
inline ::hashdb::v1::Fea* GetRequest::release_key() {
  auto temp = unsafe_arena_release_key();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::hashdb::v1::Fea* GetRequest::unsafe_arena_release_key() {
  // @@protoc_insertion_point(field_release:hashdb.v1.GetRequest.key)
  
  ::hashdb::v1::Fea* temp = key_;
  key_ = nullptr;
  return temp;
}
inline ::hashdb::v1::Fea* GetRequest::_internal_mutable_key() {
  
  if (key_ == nullptr) {
    auto* p = CreateMaybeMessage<::hashdb::v1::Fea>(GetArena());
    key_ = p;
  }
  return key_;
}
inline ::hashdb::v1::Fea* GetRequest::mutable_key() {
  // @@protoc_insertion_point(field_mutable:hashdb.v1.GetRequest.key)
  return _internal_mutable_key();
}
inline void GetRequest::set_allocated_key(::hashdb::v1::Fea* key) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete key_;
  }
  if (key) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(key);
    if (message_arena != submessage_arena) {
      key = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, key, submessage_arena);
    }
    
  } else {
    
  }
  key_ = key;
  // @@protoc_insertion_point(field_set_allocated:hashdb.v1.GetRequest.key)
}

// bool details = 3;
inline void GetRequest::clear_details() {
  details_ = false;
}
inline bool GetRequest::_internal_details() const {
  return details_;
}
inline bool GetRequest::details() const {
  // @@protoc_insertion_point(field_get:hashdb.v1.GetRequest.details)
  return _internal_details();
}
inline void GetRequest::_internal_set_details(bool value) {
  
  details_ = value;
}
inline void GetRequest::set_details(bool value) {
  _internal_set_details(value);
  // @@protoc_insertion_point(field_set:hashdb.v1.GetRequest.details)
}

// bool get_db_read_log = 4;
inline void GetRequest::clear_get_db_read_log() {
  get_db_read_log_ = false;
}
inline bool GetRequest::_internal_get_db_read_log() const {
  return get_db_read_log_;
}
inline bool GetRequest::get_db_read_log() const {
  // @@protoc_insertion_point(field_get:hashdb.v1.GetRequest.get_db_read_log)
  return _internal_get_db_read_log();
}
inline void GetRequest::_internal_set_get_db_read_log(bool value) {
  
  get_db_read_log_ = value;
}
inline void GetRequest::set_get_db_read_log(bool value) {
  _internal_set_get_db_read_log(value);
  // @@protoc_insertion_point(field_set:hashdb.v1.GetRequest.get_db_read_log)
}

// string batch_uuid = 5;
inline void GetRequest::clear_batch_uuid() {
  batch_uuid_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& GetRequest::batch_uuid() const {
  // @@protoc_insertion_point(field_get:hashdb.v1.GetRequest.batch_uuid)
  return _internal_batch_uuid();
}
inline void GetRequest::set_batch_uuid(const std::string& value) {
  _internal_set_batch_uuid(value);
  // @@protoc_insertion_point(field_set:hashdb.v1.GetRequest.batch_uuid)
}
inline std::string* GetRequest::mutable_batch_uuid() {
  // @@protoc_insertion_point(field_mutable:hashdb.v1.GetRequest.batch_uuid)
  return _internal_mutable_batch_uuid();
}
inline const std::string& GetRequest::_internal_batch_uuid() const {
  return batch_uuid_.Get();
}
inline void GetRequest::_internal_set_batch_uuid(const std::string& value) {
  
  batch_uuid_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void GetRequest::set_batch_uuid(std::string&& value) {
  
  batch_uuid_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:hashdb.v1.GetRequest.batch_uuid)
}
inline void GetRequest::set_batch_uuid(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  batch_uuid_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:hashdb.v1.GetRequest.batch_uuid)
}
inline void GetRequest::set_batch_uuid(const char* value,
    size_t size) {
  
  batch_uuid_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:hashdb.v1.GetRequest.batch_uuid)
}
inline std::string* GetRequest::_internal_mutable_batch_uuid() {
  
  return batch_uuid_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* GetRequest::release_batch_uuid() {
  // @@protoc_insertion_point(field_release:hashdb.v1.GetRequest.batch_uuid)
  return batch_uuid_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void GetRequest::set_allocated_batch_uuid(std::string* batch_uuid) {
  if (batch_uuid != nullptr) {
    
  } else {
    
  }
  batch_uuid_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), batch_uuid,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:hashdb.v1.GetRequest.batch_uuid)
}
inline std::string* GetRequest::unsafe_arena_release_batch_uuid() {
  // @@protoc_insertion_point(field_unsafe_arena_release:hashdb.v1.GetRequest.batch_uuid)
  GOOGLE_DCHECK(GetArena() != nullptr);
  
  return batch_uuid_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void GetRequest::unsafe_arena_set_allocated_batch_uuid(
    std::string* batch_uuid) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (batch_uuid != nullptr) {
    
  } else {
    
  }
  batch_uuid_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      batch_uuid, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:hashdb.v1.GetRequest.batch_uuid)
}

// -------------------------------------------------------------------

// SetProgramRequest

// .hashdb.v1.Fea key = 1;
inline bool SetProgramRequest::_internal_has_key() const {
  return this != internal_default_instance() && key_ != nullptr;
}
inline bool SetProgramRequest::has_key() const {
  return _internal_has_key();
}
inline void SetProgramRequest::clear_key() {
  if (GetArena() == nullptr && key_ != nullptr) {
    delete key_;
  }
  key_ = nullptr;
}
inline const ::hashdb::v1::Fea& SetProgramRequest::_internal_key() const {
  const ::hashdb::v1::Fea* p = key_;
  return p != nullptr ? *p : *reinterpret_cast<const ::hashdb::v1::Fea*>(
      &::hashdb::v1::_Fea_default_instance_);
}
inline const ::hashdb::v1::Fea& SetProgramRequest::key() const {
  // @@protoc_insertion_point(field_get:hashdb.v1.SetProgramRequest.key)
  return _internal_key();
}
inline void SetProgramRequest::unsafe_arena_set_allocated_key(
    ::hashdb::v1::Fea* key) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(key_);
  }
  key_ = key;
  if (key) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:hashdb.v1.SetProgramRequest.key)
}
inline ::hashdb::v1::Fea* SetProgramRequest::release_key() {
  auto temp = unsafe_arena_release_key();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::hashdb::v1::Fea* SetProgramRequest::unsafe_arena_release_key() {
  // @@protoc_insertion_point(field_release:hashdb.v1.SetProgramRequest.key)
  
  ::hashdb::v1::Fea* temp = key_;
  key_ = nullptr;
  return temp;
}
inline ::hashdb::v1::Fea* SetProgramRequest::_internal_mutable_key() {
  
  if (key_ == nullptr) {
    auto* p = CreateMaybeMessage<::hashdb::v1::Fea>(GetArena());
    key_ = p;
  }
  return key_;
}
inline ::hashdb::v1::Fea* SetProgramRequest::mutable_key() {
  // @@protoc_insertion_point(field_mutable:hashdb.v1.SetProgramRequest.key)
  return _internal_mutable_key();
}
inline void SetProgramRequest::set_allocated_key(::hashdb::v1::Fea* key) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete key_;
  }
  if (key) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(key);
    if (message_arena != submessage_arena) {
      key = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, key, submessage_arena);
    }
    
  } else {
    
  }
  key_ = key;
  // @@protoc_insertion_point(field_set_allocated:hashdb.v1.SetProgramRequest.key)
}

// bytes data = 2;
inline void SetProgramRequest::clear_data() {
  data_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& SetProgramRequest::data() const {
  // @@protoc_insertion_point(field_get:hashdb.v1.SetProgramRequest.data)
  return _internal_data();
}
inline void SetProgramRequest::set_data(const std::string& value) {
  _internal_set_data(value);
  // @@protoc_insertion_point(field_set:hashdb.v1.SetProgramRequest.data)
}
inline std::string* SetProgramRequest::mutable_data() {
  // @@protoc_insertion_point(field_mutable:hashdb.v1.SetProgramRequest.data)
  return _internal_mutable_data();
}
inline const std::string& SetProgramRequest::_internal_data() const {
  return data_.Get();
}
inline void SetProgramRequest::_internal_set_data(const std::string& value) {
  
  data_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void SetProgramRequest::set_data(std::string&& value) {
  
  data_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:hashdb.v1.SetProgramRequest.data)
}
inline void SetProgramRequest::set_data(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  data_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:hashdb.v1.SetProgramRequest.data)
}
inline void SetProgramRequest::set_data(const void* value,
    size_t size) {
  
  data_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:hashdb.v1.SetProgramRequest.data)
}
inline std::string* SetProgramRequest::_internal_mutable_data() {
  
  return data_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* SetProgramRequest::release_data() {
  // @@protoc_insertion_point(field_release:hashdb.v1.SetProgramRequest.data)
  return data_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void SetProgramRequest::set_allocated_data(std::string* data) {
  if (data != nullptr) {
    
  } else {
    
  }
  data_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), data,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:hashdb.v1.SetProgramRequest.data)
}
inline std::string* SetProgramRequest::unsafe_arena_release_data() {
  // @@protoc_insertion_point(field_unsafe_arena_release:hashdb.v1.SetProgramRequest.data)
  GOOGLE_DCHECK(GetArena() != nullptr);
  
  return data_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void SetProgramRequest::unsafe_arena_set_allocated_data(
    std::string* data) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (data != nullptr) {
    
  } else {
    
  }
  data_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      data, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:hashdb.v1.SetProgramRequest.data)
}

// bool persistent = 3;
inline void SetProgramRequest::clear_persistent() {
  persistent_ = false;
}
inline bool SetProgramRequest::_internal_persistent() const {
  return persistent_;
}
inline bool SetProgramRequest::persistent() const {
  // @@protoc_insertion_point(field_get:hashdb.v1.SetProgramRequest.persistent)
  return _internal_persistent();
}
inline void SetProgramRequest::_internal_set_persistent(bool value) {
  
  persistent_ = value;
}
inline void SetProgramRequest::set_persistent(bool value) {
  _internal_set_persistent(value);
  // @@protoc_insertion_point(field_set:hashdb.v1.SetProgramRequest.persistent)
}

// -------------------------------------------------------------------

// GetProgramRequest

// .hashdb.v1.Fea key = 1;
inline bool GetProgramRequest::_internal_has_key() const {
  return this != internal_default_instance() && key_ != nullptr;
}
inline bool GetProgramRequest::has_key() const {
  return _internal_has_key();
}
inline void GetProgramRequest::clear_key() {
  if (GetArena() == nullptr && key_ != nullptr) {
    delete key_;
  }
  key_ = nullptr;
}
inline const ::hashdb::v1::Fea& GetProgramRequest::_internal_key() const {
  const ::hashdb::v1::Fea* p = key_;
  return p != nullptr ? *p : *reinterpret_cast<const ::hashdb::v1::Fea*>(
      &::hashdb::v1::_Fea_default_instance_);
}
inline const ::hashdb::v1::Fea& GetProgramRequest::key() const {
  // @@protoc_insertion_point(field_get:hashdb.v1.GetProgramRequest.key)
  return _internal_key();
}
inline void GetProgramRequest::unsafe_arena_set_allocated_key(
    ::hashdb::v1::Fea* key) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(key_);
  }
  key_ = key;
  if (key) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:hashdb.v1.GetProgramRequest.key)
}
inline ::hashdb::v1::Fea* GetProgramRequest::release_key() {
  auto temp = unsafe_arena_release_key();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::hashdb::v1::Fea* GetProgramRequest::unsafe_arena_release_key() {
  // @@protoc_insertion_point(field_release:hashdb.v1.GetProgramRequest.key)
  
  ::hashdb::v1::Fea* temp = key_;
  key_ = nullptr;
  return temp;
}
inline ::hashdb::v1::Fea* GetProgramRequest::_internal_mutable_key() {
  
  if (key_ == nullptr) {
    auto* p = CreateMaybeMessage<::hashdb::v1::Fea>(GetArena());
    key_ = p;
  }
  return key_;
}
inline ::hashdb::v1::Fea* GetProgramRequest::mutable_key() {
  // @@protoc_insertion_point(field_mutable:hashdb.v1.GetProgramRequest.key)
  return _internal_mutable_key();
}
inline void GetProgramRequest::set_allocated_key(::hashdb::v1::Fea* key) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete key_;
  }
  if (key) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(key);
    if (message_arena != submessage_arena) {
      key = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, key, submessage_arena);
    }
    
  } else {
    
  }
  key_ = key;
  // @@protoc_insertion_point(field_set_allocated:hashdb.v1.GetProgramRequest.key)
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// LoadDBRequest

// map<string, .hashdb.v1.FeList> input_db = 1;
inline int LoadDBRequest::_internal_input_db_size() const {
  return input_db_.size();
}
inline int LoadDBRequest::input_db_size() const {
  return _internal_input_db_size();
}
inline void LoadDBRequest::clear_input_db() {
  input_db_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::hashdb::v1::FeList >&
LoadDBRequest::_internal_input_db() const {
  return input_db_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::hashdb::v1::FeList >&
LoadDBRequest::input_db() const {
  // @@protoc_insertion_point(field_map:hashdb.v1.LoadDBRequest.input_db)
  return _internal_input_db();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::hashdb::v1::FeList >*
LoadDBRequest::_internal_mutable_input_db() {
  return input_db_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::hashdb::v1::FeList >*
LoadDBRequest::mutable_input_db() {
  // @@protoc_insertion_point(field_mutable_map:hashdb.v1.LoadDBRequest.input_db)
  return _internal_mutable_input_db();
}

// bool persistent = 2;
inline void LoadDBRequest::clear_persistent() {
  persistent_ = false;
}
inline bool LoadDBRequest::_internal_persistent() const {
  return persistent_;
}
inline bool LoadDBRequest::persistent() const {
  // @@protoc_insertion_point(field_get:hashdb.v1.LoadDBRequest.persistent)
  return _internal_persistent();
}
inline void LoadDBRequest::_internal_set_persistent(bool value) {
  
  persistent_ = value;
}
inline void LoadDBRequest::set_persistent(bool value) {
  _internal_set_persistent(value);
  // @@protoc_insertion_point(field_set:hashdb.v1.LoadDBRequest.persistent)
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// LoadProgramDBRequest

// map<string, bytes> input_program_db = 1;
inline int LoadProgramDBRequest::_internal_input_program_db_size() const {
  return input_program_db_.size();
}
inline int LoadProgramDBRequest::input_program_db_size() const {
  return _internal_input_program_db_size();
}
inline void LoadProgramDBRequest::clear_input_program_db() {
  input_program_db_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
LoadProgramDBRequest::_internal_input_program_db() const {
  return input_program_db_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
LoadProgramDBRequest::input_program_db() const {
  // @@protoc_insertion_point(field_map:hashdb.v1.LoadProgramDBRequest.input_program_db)
  return _internal_input_program_db();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
LoadProgramDBRequest::_internal_mutable_input_program_db() {
  return input_program_db_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
LoadProgramDBRequest::mutable_input_program_db() {
  // @@protoc_insertion_point(field_mutable_map:hashdb.v1.LoadProgramDBRequest.input_program_db)
  return _internal_mutable_input_program_db();
}

// bool persistent = 2;
inline void LoadProgramDBRequest::clear_persistent() {
  persistent_ = false;
}
inline bool LoadProgramDBRequest::_internal_persistent() const {
  return persistent_;
}
inline bool LoadProgramDBRequest::persistent() const {
  // @@protoc_insertion_point(field_get:hashdb.v1.LoadProgramDBRequest.persistent)
  return _internal_persistent();
}
inline void LoadProgramDBRequest::_internal_set_persistent(bool value) {
  
  persistent_ = value;
}
inline void LoadProgramDBRequest::set_persistent(bool value) {
  _internal_set_persistent(value);
  // @@protoc_insertion_point(field_set:hashdb.v1.LoadProgramDBRequest.persistent)
}

// -------------------------------------------------------------------

// FlushRequest

// string batch_uuid = 1;
inline void FlushRequest::clear_batch_uuid() {
  batch_uuid_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& FlushRequest::batch_uuid() const {
  // @@protoc_insertion_point(field_get:hashdb.v1.FlushRequest.batch_uuid)
  return _internal_batch_uuid();
}
inline void FlushRequest::set_batch_uuid(const std::string& value) {
  _internal_set_batch_uuid(value);
  // @@protoc_insertion_point(field_set:hashdb.v1.FlushRequest.batch_uuid)
}
inline std::string* FlushRequest::mutable_batch_uuid() {
  // @@protoc_insertion_point(field_mutable:hashdb.v1.FlushRequest.batch_uuid)
  return _internal_mutable_batch_uuid();
}
inline const std::string& FlushRequest::_internal_batch_uuid() const {
  return batch_uuid_.Get();
}
inline void FlushRequest::_internal_set_batch_uuid(const std::string& value) {
  
  batch_uuid_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void FlushRequest::set_batch_uuid(std::string&& value) {
  
  batch_uuid_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:hashdb.v1.FlushRequest.batch_uuid)
}
inline void FlushRequest::set_batch_uuid(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  batch_uuid_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:hashdb.v1.FlushRequest.batch_uuid)
}
inline void FlushRequest::set_batch_uuid(const char* value,
    size_t size) {
  
  batch_uuid_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:hashdb.v1.FlushRequest.batch_uuid)
}
inline std::string* FlushRequest::_internal_mutable_batch_uuid() {
  
  return batch_uuid_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* FlushRequest::release_batch_uuid() {
  // @@protoc_insertion_point(field_release:hashdb.v1.FlushRequest.batch_uuid)
  return batch_uuid_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void FlushRequest::set_allocated_batch_uuid(std::string* batch_uuid) {
  if (batch_uuid != nullptr) {
    
  } else {
    
  }
  batch_uuid_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), batch_uuid,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:hashdb.v1.FlushRequest.batch_uuid)
}
inline std::string* FlushRequest::unsafe_arena_release_batch_uuid() {
  // @@protoc_insertion_point(field_unsafe_arena_release:hashdb.v1.FlushRequest.batch_uuid)
  GOOGLE_DCHECK(GetArena() != nullptr);
  
  return batch_uuid_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void FlushRequest::unsafe_arena_set_allocated_batch_uuid(
    std::string* batch_uuid) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (batch_uuid != nullptr) {
    
  } else {
    
  }
  batch_uuid_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      batch_uuid, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:hashdb.v1.FlushRequest.batch_uuid)
}

// string new_state_root = 2;
inline void FlushRequest::clear_new_state_root() {
  new_state_root_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& FlushRequest::new_state_root() const {
  // @@protoc_insertion_point(field_get:hashdb.v1.FlushRequest.new_state_root)
  return _internal_new_state_root();
}
inline void FlushRequest::set_new_state_root(const std::string& value) {
  _internal_set_new_state_root(value);
  // @@protoc_insertion_point(field_set:hashdb.v1.FlushRequest.new_state_root)
}
inline std::string* FlushRequest::mutable_new_state_root() {
  // @@protoc_insertion_point(field_mutable:hashdb.v1.FlushRequest.new_state_root)
  return _internal_mutable_new_state_root();
}
inline const std::string& FlushRequest::_internal_new_state_root() const {
  return new_state_root_.Get();
}
inline void FlushRequest::_internal_set_new_state_root(const std::string& value) {
  
  new_state_root_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void FlushRequest::set_new_state_root(std::string&& value) {
  
  new_state_root_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:hashdb.v1.FlushRequest.new_state_root)
}
inline void FlushRequest::set_new_state_root(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  new_state_root_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:hashdb.v1.FlushRequest.new_state_root)
}
inline void FlushRequest::set_new_state_root(const char* value,
    size_t size) {
  
  new_state_root_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:hashdb.v1.FlushRequest.new_state_root)
}
inline std::string* FlushRequest::_internal_mutable_new_state_root() {
  
  return new_state_root_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* FlushRequest::release_new_state_root() {
  // @@protoc_insertion_point(field_release:hashdb.v1.FlushRequest.new_state_root)
  return new_state_root_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void FlushRequest::set_allocated_new_state_root(std::string* new_state_root) {
  if (new_state_root != nullptr) {
    
  } else {
    
  }
  new_state_root_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), new_state_root,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:hashdb.v1.FlushRequest.new_state_root)
}
inline std::string* FlushRequest::unsafe_arena_release_new_state_root() {
  // @@protoc_insertion_point(field_unsafe_arena_release:hashdb.v1.FlushRequest.new_state_root)
  GOOGLE_DCHECK(GetArena() != nullptr);
  
  return new_state_root_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void FlushRequest::unsafe_arena_set_allocated_new_state_root(
    std::string* new_state_root) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (new_state_root != nullptr) {
    
  } else {
    
  }
  new_state_root_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      new_state_root, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:hashdb.v1.FlushRequest.new_state_root)
}

// .hashdb.v1.Persistence persistence = 3;
inline void FlushRequest::clear_persistence() {
  persistence_ = 0;
}
inline ::hashdb::v1::Persistence FlushRequest::_internal_persistence() const {
  return static_cast< ::hashdb::v1::Persistence >(persistence_);
}
inline ::hashdb::v1::Persistence FlushRequest::persistence() const {
  // @@protoc_insertion_point(field_get:hashdb.v1.FlushRequest.persistence)
  return _internal_persistence();
}
inline void FlushRequest::_internal_set_persistence(::hashdb::v1::Persistence value) {
  
  persistence_ = value;
}
inline void FlushRequest::set_persistence(::hashdb::v1::Persistence value) {
  _internal_set_persistence(value);
  // @@protoc_insertion_point(field_set:hashdb.v1.FlushRequest.persistence)
}

// -------------------------------------------------------------------

// SemiFlushRequest

// string batch_uuid = 1;
inline void SemiFlushRequest::clear_batch_uuid() {
  batch_uuid_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& SemiFlushRequest::batch_uuid() const {
  // @@protoc_insertion_point(field_get:hashdb.v1.SemiFlushRequest.batch_uuid)
  return _internal_batch_uuid();
}
inline void SemiFlushRequest::set_batch_uuid(const std::string& value) {
  _internal_set_batch_uuid(value);
  // @@protoc_insertion_point(field_set:hashdb.v1.SemiFlushRequest.batch_uuid)
}
inline std::string* SemiFlushRequest::mutable_batch_uuid() {
  // @@protoc_insertion_point(field_mutable:hashdb.v1.SemiFlushRequest.batch_uuid)
  return _internal_mutable_batch_uuid();
}
inline const std::string& SemiFlushRequest::_internal_batch_uuid() const {
  return batch_uuid_.Get();
}
inline void SemiFlushRequest::_internal_set_batch_uuid(const std::string& value) {
  
  batch_uuid_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void SemiFlushRequest::set_batch_uuid(std::string&& value) {
  
  batch_uuid_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:hashdb.v1.SemiFlushRequest.batch_uuid)
}
inline void SemiFlushRequest::set_batch_uuid(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  batch_uuid_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:hashdb.v1.SemiFlushRequest.batch_uuid)
}
inline void SemiFlushRequest::set_batch_uuid(const char* value,
    size_t size) {
  
  batch_uuid_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:hashdb.v1.SemiFlushRequest.batch_uuid)
}
inline std::string* SemiFlushRequest::_internal_mutable_batch_uuid() {
  
  return batch_uuid_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* SemiFlushRequest::release_batch_uuid() {
  // @@protoc_insertion_point(field_release:hashdb.v1.SemiFlushRequest.batch_uuid)
  return batch_uuid_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void SemiFlushRequest::set_allocated_batch_uuid(std::string* batch_uuid) {
  if (batch_uuid != nullptr) {
    
  } else {
    
  }
  batch_uuid_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), batch_uuid,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:hashdb.v1.SemiFlushRequest.batch_uuid)
}
inline std::string* SemiFlushRequest::unsafe_arena_release_batch_uuid() {
  // @@protoc_insertion_point(field_unsafe_arena_release:hashdb.v1.SemiFlushRequest.batch_uuid)
  GOOGLE_DCHECK(GetArena() != nullptr);
  
  return batch_uuid_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void SemiFlushRequest::unsafe_arena_set_allocated_batch_uuid(
    std::string* batch_uuid) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (batch_uuid != nullptr) {
    
  } else {
    
  }
  batch_uuid_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      batch_uuid, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:hashdb.v1.SemiFlushRequest.batch_uuid)
}

// string new_state_root = 2;
inline void SemiFlushRequest::clear_new_state_root() {
  new_state_root_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& SemiFlushRequest::new_state_root() const {
  // @@protoc_insertion_point(field_get:hashdb.v1.SemiFlushRequest.new_state_root)
  return _internal_new_state_root();
}
inline void SemiFlushRequest::set_new_state_root(const std::string& value) {
  _internal_set_new_state_root(value);
  // @@protoc_insertion_point(field_set:hashdb.v1.SemiFlushRequest.new_state_root)
}
inline std::string* SemiFlushRequest::mutable_new_state_root() {
  // @@protoc_insertion_point(field_mutable:hashdb.v1.SemiFlushRequest.new_state_root)
  return _internal_mutable_new_state_root();
}
inline const std::string& SemiFlushRequest::_internal_new_state_root() const {
  return new_state_root_.Get();
}
inline void SemiFlushRequest::_internal_set_new_state_root(const std::string& value) {
  
  new_state_root_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void SemiFlushRequest::set_new_state_root(std::string&& value) {
  
  new_state_root_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:hashdb.v1.SemiFlushRequest.new_state_root)
}
inline void SemiFlushRequest::set_new_state_root(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  new_state_root_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:hashdb.v1.SemiFlushRequest.new_state_root)
}
inline void SemiFlushRequest::set_new_state_root(const char* value,
    size_t size) {
  
  new_state_root_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:hashdb.v1.SemiFlushRequest.new_state_root)
}
inline std::string* SemiFlushRequest::_internal_mutable_new_state_root() {
  
  return new_state_root_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* SemiFlushRequest::release_new_state_root() {
  // @@protoc_insertion_point(field_release:hashdb.v1.SemiFlushRequest.new_state_root)
  return new_state_root_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void SemiFlushRequest::set_allocated_new_state_root(std::string* new_state_root) {
  if (new_state_root != nullptr) {
    
  } else {
    
  }
  new_state_root_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), new_state_root,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:hashdb.v1.SemiFlushRequest.new_state_root)
}
inline std::string* SemiFlushRequest::unsafe_arena_release_new_state_root() {
  // @@protoc_insertion_point(field_unsafe_arena_release:hashdb.v1.SemiFlushRequest.new_state_root)
  GOOGLE_DCHECK(GetArena() != nullptr);
  
  return new_state_root_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void SemiFlushRequest::unsafe_arena_set_allocated_new_state_root(
    std::string* new_state_root) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (new_state_root != nullptr) {
    
  } else {
    
  }
  new_state_root_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      new_state_root, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:hashdb.v1.SemiFlushRequest.new_state_root)
}

// .hashdb.v1.Persistence persistence = 3;
inline void SemiFlushRequest::clear_persistence() {
  persistence_ = 0;
}
inline ::hashdb::v1::Persistence SemiFlushRequest::_internal_persistence() const {
  return static_cast< ::hashdb::v1::Persistence >(persistence_);
}
inline ::hashdb::v1::Persistence SemiFlushRequest::persistence() const {
  // @@protoc_insertion_point(field_get:hashdb.v1.SemiFlushRequest.persistence)
  return _internal_persistence();
}
inline void SemiFlushRequest::_internal_set_persistence(::hashdb::v1::Persistence value) {
  
  persistence_ = value;
}
inline void SemiFlushRequest::set_persistence(::hashdb::v1::Persistence value) {
  _internal_set_persistence(value);
  // @@protoc_insertion_point(field_set:hashdb.v1.SemiFlushRequest.persistence)
}

// -------------------------------------------------------------------

// GetFlushDataRequest

// uint64 flush_id = 1;
inline void GetFlushDataRequest::clear_flush_id() {
  flush_id_ = PROTOBUF_ULONGLONG(0);
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 GetFlushDataRequest::_internal_flush_id() const {
  return flush_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 GetFlushDataRequest::flush_id() const {
  // @@protoc_insertion_point(field_get:hashdb.v1.GetFlushDataRequest.flush_id)
  return _internal_flush_id();
}
inline void GetFlushDataRequest::_internal_set_flush_id(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  
  flush_id_ = value;
}
inline void GetFlushDataRequest::set_flush_id(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_flush_id(value);
  // @@protoc_insertion_point(field_set:hashdb.v1.GetFlushDataRequest.flush_id)
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// SetResponse

// .hashdb.v1.Fea old_root = 1;
inline bool SetResponse::_internal_has_old_root() const {
  return this != internal_default_instance() && old_root_ != nullptr;
}
inline bool SetResponse::has_old_root() const {
  return _internal_has_old_root();
}
inline void SetResponse::clear_old_root() {
  if (GetArena() == nullptr && old_root_ != nullptr) {
    delete old_root_;
  }
  old_root_ = nullptr;
}
inline const ::hashdb::v1::Fea& SetResponse::_internal_old_root() const {
  const ::hashdb::v1::Fea* p = old_root_;
  return p != nullptr ? *p : *reinterpret_cast<const ::hashdb::v1::Fea*>(
      &::hashdb::v1::_Fea_default_instance_);
}
inline const ::hashdb::v1::Fea& SetResponse::old_root() const {
  // @@protoc_insertion_point(field_get:hashdb.v1.SetResponse.old_root)
  return _internal_old_root();
}
inline void SetResponse::unsafe_arena_set_allocated_old_root(
    ::hashdb::v1::Fea* old_root) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(old_root_);
  }
  old_root_ = old_root;
  if (old_root) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:hashdb.v1.SetResponse.old_root)
}
inline ::hashdb::v1::Fea* SetResponse::release_old_root() {
  auto temp = unsafe_arena_release_old_root();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::hashdb::v1::Fea* SetResponse::unsafe_arena_release_old_root() {
  // @@protoc_insertion_point(field_release:hashdb.v1.SetResponse.old_root)
  
  ::hashdb::v1::Fea* temp = old_root_;
  old_root_ = nullptr;
  return temp;
}
inline ::hashdb::v1::Fea* SetResponse::_internal_mutable_old_root() {
  
  if (old_root_ == nullptr) {
    auto* p = CreateMaybeMessage<::hashdb::v1::Fea>(GetArena());
    old_root_ = p;
  }
  return old_root_;
}
inline ::hashdb::v1::Fea* SetResponse::mutable_old_root() {
  // @@protoc_insertion_point(field_mutable:hashdb.v1.SetResponse.old_root)
  return _internal_mutable_old_root();
}
inline void SetResponse::set_allocated_old_root(::hashdb::v1::Fea* old_root) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete old_root_;
  }
  if (old_root) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(old_root);
    if (message_arena != submessage_arena) {
      old_root = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, old_root, submessage_arena);
    }
    
  } else {
    
  }
  old_root_ = old_root;
  // @@protoc_insertion_point(field_set_allocated:hashdb.v1.SetResponse.old_root)
}

// .hashdb.v1.Fea new_root = 2;
inline bool SetResponse::_internal_has_new_root() const {
  return this != internal_default_instance() && new_root_ != nullptr;
}
inline bool SetResponse::has_new_root() const {
  return _internal_has_new_root();
}
inline void SetResponse::clear_new_root() {
  if (GetArena() == nullptr && new_root_ != nullptr) {
    delete new_root_;
  }
  new_root_ = nullptr;
}
inline const ::hashdb::v1::Fea& SetResponse::_internal_new_root() const {
  const ::hashdb::v1::Fea* p = new_root_;
  return p != nullptr ? *p : *reinterpret_cast<const ::hashdb::v1::Fea*>(
      &::hashdb::v1::_Fea_default_instance_);
}
inline const ::hashdb::v1::Fea& SetResponse::new_root() const {
  // @@protoc_insertion_point(field_get:hashdb.v1.SetResponse.new_root)
  return _internal_new_root();
}
inline void SetResponse::unsafe_arena_set_allocated_new_root(
    ::hashdb::v1::Fea* new_root) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(new_root_);
  }
  new_root_ = new_root;
  if (new_root) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:hashdb.v1.SetResponse.new_root)
}
inline ::hashdb::v1::Fea* SetResponse::release_new_root() {
  auto temp = unsafe_arena_release_new_root();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::hashdb::v1::Fea* SetResponse::unsafe_arena_release_new_root() {
  // @@protoc_insertion_point(field_release:hashdb.v1.SetResponse.new_root)
  
  ::hashdb::v1::Fea* temp = new_root_;
  new_root_ = nullptr;
  return temp;
}
inline ::hashdb::v1::Fea* SetResponse::_internal_mutable_new_root() {
  
  if (new_root_ == nullptr) {
    auto* p = CreateMaybeMessage<::hashdb::v1::Fea>(GetArena());
    new_root_ = p;
  }
  return new_root_;
}
inline ::hashdb::v1::Fea* SetResponse::mutable_new_root() {
  // @@protoc_insertion_point(field_mutable:hashdb.v1.SetResponse.new_root)
  return _internal_mutable_new_root();
}
inline void SetResponse::set_allocated_new_root(::hashdb::v1::Fea* new_root) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete new_root_;
  }
  if (new_root) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(new_root);
    if (message_arena != submessage_arena) {
      new_root = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, new_root, submessage_arena);
    }
    
  } else {
    
  }
  new_root_ = new_root;
  // @@protoc_insertion_point(field_set_allocated:hashdb.v1.SetResponse.new_root)
}

// .hashdb.v1.Fea key = 3;
inline bool SetResponse::_internal_has_key() const {
  return this != internal_default_instance() && key_ != nullptr;
}
inline bool SetResponse::has_key() const {
  return _internal_has_key();
}
inline void SetResponse::clear_key() {
  if (GetArena() == nullptr && key_ != nullptr) {
    delete key_;
  }
  key_ = nullptr;
}
inline const ::hashdb::v1::Fea& SetResponse::_internal_key() const {
  const ::hashdb::v1::Fea* p = key_;
  return p != nullptr ? *p : *reinterpret_cast<const ::hashdb::v1::Fea*>(
      &::hashdb::v1::_Fea_default_instance_);
}
inline const ::hashdb::v1::Fea& SetResponse::key() const {
  // @@protoc_insertion_point(field_get:hashdb.v1.SetResponse.key)
  return _internal_key();
}
inline void SetResponse::unsafe_arena_set_allocated_key(
    ::hashdb::v1::Fea* key) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(key_);
  }
  key_ = key;
  if (key) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:hashdb.v1.SetResponse.key)
}
inline ::hashdb::v1::Fea* SetResponse::release_key() {
  auto temp = unsafe_arena_release_key();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::hashdb::v1::Fea* SetResponse::unsafe_arena_release_key() {
  // @@protoc_insertion_point(field_release:hashdb.v1.SetResponse.key)
  
  ::hashdb::v1::Fea* temp = key_;
  key_ = nullptr;
  return temp;
}
inline ::hashdb::v1::Fea* SetResponse::_internal_mutable_key() {
  
  if (key_ == nullptr) {
    auto* p = CreateMaybeMessage<::hashdb::v1::Fea>(GetArena());
    key_ = p;
  }
  return key_;
}
inline ::hashdb::v1::Fea* SetResponse::mutable_key() {
  // @@protoc_insertion_point(field_mutable:hashdb.v1.SetResponse.key)
  return _internal_mutable_key();
}
inline void SetResponse::set_allocated_key(::hashdb::v1::Fea* key) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete key_;
  }
  if (key) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(key);
    if (message_arena != submessage_arena) {
      key = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, key, submessage_arena);
    }
    
  } else {
    
  }
  key_ = key;
  // @@protoc_insertion_point(field_set_allocated:hashdb.v1.SetResponse.key)
}

// map<uint64, .hashdb.v1.SiblingList> siblings = 4;
inline int SetResponse::_internal_siblings_size() const {
  return siblings_.size();
}
inline int SetResponse::siblings_size() const {
  return _internal_siblings_size();
}
inline void SetResponse::clear_siblings() {
  siblings_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< ::PROTOBUF_NAMESPACE_ID::uint64, ::hashdb::v1::SiblingList >&
SetResponse::_internal_siblings() const {
  return siblings_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< ::PROTOBUF_NAMESPACE_ID::uint64, ::hashdb::v1::SiblingList >&
SetResponse::siblings() const {
  // @@protoc_insertion_point(field_map:hashdb.v1.SetResponse.siblings)
  return _internal_siblings();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< ::PROTOBUF_NAMESPACE_ID::uint64, ::hashdb::v1::SiblingList >*
SetResponse::_internal_mutable_siblings() {
  return siblings_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< ::PROTOBUF_NAMESPACE_ID::uint64, ::hashdb::v1::SiblingList >*
SetResponse::mutable_siblings() {
  // @@protoc_insertion_point(field_mutable_map:hashdb.v1.SetResponse.siblings)
  return _internal_mutable_siblings();
}

// .hashdb.v1.Fea ins_key = 5;
inline bool SetResponse::_internal_has_ins_key() const {
  return this != internal_default_instance() && ins_key_ != nullptr;
}
inline bool SetResponse::has_ins_key() const {
  return _internal_has_ins_key();
}
inline void SetResponse::clear_ins_key() {
  if (GetArena() == nullptr && ins_key_ != nullptr) {
    delete ins_key_;
  }
  ins_key_ = nullptr;
}
inline const ::hashdb::v1::Fea& SetResponse::_internal_ins_key() const {
  const ::hashdb::v1::Fea* p = ins_key_;
  return p != nullptr ? *p : *reinterpret_cast<const ::hashdb::v1::Fea*>(
      &::hashdb::v1::_Fea_default_instance_);
}
inline const ::hashdb::v1::Fea& SetResponse::ins_key() const {
  // @@protoc_insertion_point(field_get:hashdb.v1.SetResponse.ins_key)
  return _internal_ins_key();
}
inline void SetResponse::unsafe_arena_set_allocated_ins_key(
    ::hashdb::v1::Fea* ins_key) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(ins_key_);
  }
  ins_key_ = ins_key;
  if (ins_key) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:hashdb.v1.SetResponse.ins_key)
}
inline ::hashdb::v1::Fea* SetResponse::release_ins_key() {
  auto temp = unsafe_arena_release_ins_key();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::hashdb::v1::Fea* SetResponse::unsafe_arena_release_ins_key() {
  // @@protoc_insertion_point(field_release:hashdb.v1.SetResponse.ins_key)
  
  ::hashdb::v1::Fea* temp = ins_key_;
  ins_key_ = nullptr;
  return temp;
}
inline ::hashdb::v1::Fea* SetResponse::_internal_mutable_ins_key() {
  
  if (ins_key_ == nullptr) {
    auto* p = CreateMaybeMessage<::hashdb::v1::Fea>(GetArena());
    ins_key_ = p;
  }
  return ins_key_;
}
inline ::hashdb::v1::Fea* SetResponse::mutable_ins_key() {
  // @@protoc_insertion_point(field_mutable:hashdb.v1.SetResponse.ins_key)
  return _internal_mutable_ins_key();
}
inline void SetResponse::set_allocated_ins_key(::hashdb::v1::Fea* ins_key) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete ins_key_;
  }
  if (ins_key) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(ins_key);
    if (message_arena != submessage_arena) {
      ins_key = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, ins_key, submessage_arena);
    }
    
  } else {
    
  }
  ins_key_ = ins_key;
  // @@protoc_insertion_point(field_set_allocated:hashdb.v1.SetResponse.ins_key)
}

// string ins_value = 6;
inline void SetResponse::clear_ins_value() {
  ins_value_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& SetResponse::ins_value() const {
  // @@protoc_insertion_point(field_get:hashdb.v1.SetResponse.ins_value)
  return _internal_ins_value();
}
inline void SetResponse::set_ins_value(const std::string& value) {
  _internal_set_ins_value(value);
  // @@protoc_insertion_point(field_set:hashdb.v1.SetResponse.ins_value)
}
inline std::string* SetResponse::mutable_ins_value() {
  // @@protoc_insertion_point(field_mutable:hashdb.v1.SetResponse.ins_value)
  return _internal_mutable_ins_value();
}
inline const std::string& SetResponse::_internal_ins_value() const {
  return ins_value_.Get();
}
inline void SetResponse::_internal_set_ins_value(const std::string& value) {
  
  ins_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void SetResponse::set_ins_value(std::string&& value) {
  
  ins_value_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:hashdb.v1.SetResponse.ins_value)
}
inline void SetResponse::set_ins_value(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  ins_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:hashdb.v1.SetResponse.ins_value)
}
inline void SetResponse::set_ins_value(const char* value,
    size_t size) {
  
  ins_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:hashdb.v1.SetResponse.ins_value)
}
inline std::string* SetResponse::_internal_mutable_ins_value() {
  
  return ins_value_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* SetResponse::release_ins_value() {
  // @@protoc_insertion_point(field_release:hashdb.v1.SetResponse.ins_value)
  return ins_value_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void SetResponse::set_allocated_ins_value(std::string* ins_value) {
  if (ins_value != nullptr) {
    
  } else {
    
  }
  ins_value_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ins_value,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:hashdb.v1.SetResponse.ins_value)
}
inline std::string* SetResponse::unsafe_arena_release_ins_value() {
  // @@protoc_insertion_point(field_unsafe_arena_release:hashdb.v1.SetResponse.ins_value)
  GOOGLE_DCHECK(GetArena() != nullptr);
  
  return ins_value_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void SetResponse::unsafe_arena_set_allocated_ins_value(
    std::string* ins_value) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (ins_value != nullptr) {
    
  } else {
    
  }
  ins_value_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ins_value, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:hashdb.v1.SetResponse.ins_value)
}

// bool is_old0 = 7;
inline void SetResponse::clear_is_old0() {
  is_old0_ = false;
}
inline bool SetResponse::_internal_is_old0() const {
  return is_old0_;
}
inline bool SetResponse::is_old0() const {
  // @@protoc_insertion_point(field_get:hashdb.v1.SetResponse.is_old0)
  return _internal_is_old0();
}
inline void SetResponse::_internal_set_is_old0(bool value) {
  
  is_old0_ = value;
}
inline void SetResponse::set_is_old0(bool value) {
  _internal_set_is_old0(value);
  // @@protoc_insertion_point(field_set:hashdb.v1.SetResponse.is_old0)
}

// string old_value = 8;
inline void SetResponse::clear_old_value() {
  old_value_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& SetResponse::old_value() const {
  // @@protoc_insertion_point(field_get:hashdb.v1.SetResponse.old_value)
  return _internal_old_value();
}
inline void SetResponse::set_old_value(const std::string& value) {
  _internal_set_old_value(value);
  // @@protoc_insertion_point(field_set:hashdb.v1.SetResponse.old_value)
}
inline std::string* SetResponse::mutable_old_value() {
  // @@protoc_insertion_point(field_mutable:hashdb.v1.SetResponse.old_value)
  return _internal_mutable_old_value();
}
inline const std::string& SetResponse::_internal_old_value() const {
  return old_value_.Get();
}
inline void SetResponse::_internal_set_old_value(const std::string& value) {
  
  old_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void SetResponse::set_old_value(std::string&& value) {
  
  old_value_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:hashdb.v1.SetResponse.old_value)
}
inline void SetResponse::set_old_value(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  old_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:hashdb.v1.SetResponse.old_value)
}
inline void SetResponse::set_old_value(const char* value,
    size_t size) {
  
  old_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:hashdb.v1.SetResponse.old_value)
}
inline std::string* SetResponse::_internal_mutable_old_value() {
  
  return old_value_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* SetResponse::release_old_value() {
  // @@protoc_insertion_point(field_release:hashdb.v1.SetResponse.old_value)
  return old_value_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void SetResponse::set_allocated_old_value(std::string* old_value) {
  if (old_value != nullptr) {
    
  } else {
    
  }
  old_value_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), old_value,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:hashdb.v1.SetResponse.old_value)
}
inline std::string* SetResponse::unsafe_arena_release_old_value() {
  // @@protoc_insertion_point(field_unsafe_arena_release:hashdb.v1.SetResponse.old_value)
  GOOGLE_DCHECK(GetArena() != nullptr);
  
  return old_value_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void SetResponse::unsafe_arena_set_allocated_old_value(
    std::string* old_value) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (old_value != nullptr) {
    
  } else {
    
  }
  old_value_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      old_value, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:hashdb.v1.SetResponse.old_value)
}

// string new_value = 9;
inline void SetResponse::clear_new_value() {
  new_value_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& SetResponse::new_value() const {
  // @@protoc_insertion_point(field_get:hashdb.v1.SetResponse.new_value)
  return _internal_new_value();
}
inline void SetResponse::set_new_value(const std::string& value) {
  _internal_set_new_value(value);
  // @@protoc_insertion_point(field_set:hashdb.v1.SetResponse.new_value)
}
inline std::string* SetResponse::mutable_new_value() {
  // @@protoc_insertion_point(field_mutable:hashdb.v1.SetResponse.new_value)
  return _internal_mutable_new_value();
}
inline const std::string& SetResponse::_internal_new_value() const {
  return new_value_.Get();
}
inline void SetResponse::_internal_set_new_value(const std::string& value) {
  
  new_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void SetResponse::set_new_value(std::string&& value) {
  
  new_value_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:hashdb.v1.SetResponse.new_value)
}
inline void SetResponse::set_new_value(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  new_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:hashdb.v1.SetResponse.new_value)
}
inline void SetResponse::set_new_value(const char* value,
    size_t size) {
  
  new_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:hashdb.v1.SetResponse.new_value)
}
inline std::string* SetResponse::_internal_mutable_new_value() {
  
  return new_value_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* SetResponse::release_new_value() {
  // @@protoc_insertion_point(field_release:hashdb.v1.SetResponse.new_value)
  return new_value_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void SetResponse::set_allocated_new_value(std::string* new_value) {
  if (new_value != nullptr) {
    
  } else {
    
  }
  new_value_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), new_value,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:hashdb.v1.SetResponse.new_value)
}
inline std::string* SetResponse::unsafe_arena_release_new_value() {
  // @@protoc_insertion_point(field_unsafe_arena_release:hashdb.v1.SetResponse.new_value)
  GOOGLE_DCHECK(GetArena() != nullptr);
  
  return new_value_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void SetResponse::unsafe_arena_set_allocated_new_value(
    std::string* new_value) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (new_value != nullptr) {
    
  } else {
    
  }
  new_value_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      new_value, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:hashdb.v1.SetResponse.new_value)
}

// string mode = 10;
inline void SetResponse::clear_mode() {
  mode_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& SetResponse::mode() const {
  // @@protoc_insertion_point(field_get:hashdb.v1.SetResponse.mode)
  return _internal_mode();
}
inline void SetResponse::set_mode(const std::string& value) {
  _internal_set_mode(value);
  // @@protoc_insertion_point(field_set:hashdb.v1.SetResponse.mode)
}
inline std::string* SetResponse::mutable_mode() {
  // @@protoc_insertion_point(field_mutable:hashdb.v1.SetResponse.mode)
  return _internal_mutable_mode();
}
inline const std::string& SetResponse::_internal_mode() const {
  return mode_.Get();
}
inline void SetResponse::_internal_set_mode(const std::string& value) {
  
  mode_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void SetResponse::set_mode(std::string&& value) {
  
  mode_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:hashdb.v1.SetResponse.mode)
}
inline void SetResponse::set_mode(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  mode_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:hashdb.v1.SetResponse.mode)
}
inline void SetResponse::set_mode(const char* value,
    size_t size) {
  
  mode_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:hashdb.v1.SetResponse.mode)
}
inline std::string* SetResponse::_internal_mutable_mode() {
  
  return mode_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* SetResponse::release_mode() {
  // @@protoc_insertion_point(field_release:hashdb.v1.SetResponse.mode)
  return mode_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void SetResponse::set_allocated_mode(std::string* mode) {
  if (mode != nullptr) {
    
  } else {
    
  }
  mode_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), mode,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:hashdb.v1.SetResponse.mode)
}
inline std::string* SetResponse::unsafe_arena_release_mode() {
  // @@protoc_insertion_point(field_unsafe_arena_release:hashdb.v1.SetResponse.mode)
  GOOGLE_DCHECK(GetArena() != nullptr);
  
  return mode_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void SetResponse::unsafe_arena_set_allocated_mode(
    std::string* mode) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (mode != nullptr) {
    
  } else {
    
  }
  mode_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      mode, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:hashdb.v1.SetResponse.mode)
}

// uint64 proof_hash_counter = 11;
inline void SetResponse::clear_proof_hash_counter() {
  proof_hash_counter_ = PROTOBUF_ULONGLONG(0);
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 SetResponse::_internal_proof_hash_counter() const {
  return proof_hash_counter_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 SetResponse::proof_hash_counter() const {
  // @@protoc_insertion_point(field_get:hashdb.v1.SetResponse.proof_hash_counter)
  return _internal_proof_hash_counter();
}
inline void SetResponse::_internal_set_proof_hash_counter(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  
  proof_hash_counter_ = value;
}
inline void SetResponse::set_proof_hash_counter(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_proof_hash_counter(value);
  // @@protoc_insertion_point(field_set:hashdb.v1.SetResponse.proof_hash_counter)
}

// map<string, .hashdb.v1.FeList> db_read_log = 12;
inline int SetResponse::_internal_db_read_log_size() const {
  return db_read_log_.size();
}
inline int SetResponse::db_read_log_size() const {
  return _internal_db_read_log_size();
}
inline void SetResponse::clear_db_read_log() {
  db_read_log_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::hashdb::v1::FeList >&
SetResponse::_internal_db_read_log() const {
  return db_read_log_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::hashdb::v1::FeList >&
SetResponse::db_read_log() const {
  // @@protoc_insertion_point(field_map:hashdb.v1.SetResponse.db_read_log)
  return _internal_db_read_log();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::hashdb::v1::FeList >*
SetResponse::_internal_mutable_db_read_log() {
  return db_read_log_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::hashdb::v1::FeList >*
SetResponse::mutable_db_read_log() {
  // @@protoc_insertion_point(field_mutable_map:hashdb.v1.SetResponse.db_read_log)
  return _internal_mutable_db_read_log();
}

// .hashdb.v1.ResultCode result = 13;
inline bool SetResponse::_internal_has_result() const {
  return this != internal_default_instance() && result_ != nullptr;
}
inline bool SetResponse::has_result() const {
  return _internal_has_result();
}
inline void SetResponse::clear_result() {
  if (GetArena() == nullptr && result_ != nullptr) {
    delete result_;
  }
  result_ = nullptr;
}
inline const ::hashdb::v1::ResultCode& SetResponse::_internal_result() const {
  const ::hashdb::v1::ResultCode* p = result_;
  return p != nullptr ? *p : *reinterpret_cast<const ::hashdb::v1::ResultCode*>(
      &::hashdb::v1::_ResultCode_default_instance_);
}
inline const ::hashdb::v1::ResultCode& SetResponse::result() const {
  // @@protoc_insertion_point(field_get:hashdb.v1.SetResponse.result)
  return _internal_result();
}
inline void SetResponse::unsafe_arena_set_allocated_result(
    ::hashdb::v1::ResultCode* result) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(result_);
  }
  result_ = result;
  if (result) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:hashdb.v1.SetResponse.result)
}
inline ::hashdb::v1::ResultCode* SetResponse::release_result() {
  auto temp = unsafe_arena_release_result();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::hashdb::v1::ResultCode* SetResponse::unsafe_arena_release_result() {
  // @@protoc_insertion_point(field_release:hashdb.v1.SetResponse.result)
  
  ::hashdb::v1::ResultCode* temp = result_;
  result_ = nullptr;
  return temp;
}
inline ::hashdb::v1::ResultCode* SetResponse::_internal_mutable_result() {
  
  if (result_ == nullptr) {
    auto* p = CreateMaybeMessage<::hashdb::v1::ResultCode>(GetArena());
    result_ = p;
  }
  return result_;
}
inline ::hashdb::v1::ResultCode* SetResponse::mutable_result() {
  // @@protoc_insertion_point(field_mutable:hashdb.v1.SetResponse.result)
  return _internal_mutable_result();
}
inline void SetResponse::set_allocated_result(::hashdb::v1::ResultCode* result) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete result_;
  }
  if (result) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(result);
    if (message_arena != submessage_arena) {
      result = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, result, submessage_arena);
    }
    
  } else {
    
  }
  result_ = result;
  // @@protoc_insertion_point(field_set_allocated:hashdb.v1.SetResponse.result)
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// GetResponse

// .hashdb.v1.Fea root = 1;
inline bool GetResponse::_internal_has_root() const {
  return this != internal_default_instance() && root_ != nullptr;
}
inline bool GetResponse::has_root() const {
  return _internal_has_root();
}
inline void GetResponse::clear_root() {
  if (GetArena() == nullptr && root_ != nullptr) {
    delete root_;
  }
  root_ = nullptr;
}
inline const ::hashdb::v1::Fea& GetResponse::_internal_root() const {
  const ::hashdb::v1::Fea* p = root_;
  return p != nullptr ? *p : *reinterpret_cast<const ::hashdb::v1::Fea*>(
      &::hashdb::v1::_Fea_default_instance_);
}
inline const ::hashdb::v1::Fea& GetResponse::root() const {
  // @@protoc_insertion_point(field_get:hashdb.v1.GetResponse.root)
  return _internal_root();
}
inline void GetResponse::unsafe_arena_set_allocated_root(
    ::hashdb::v1::Fea* root) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(root_);
  }
  root_ = root;
  if (root) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:hashdb.v1.GetResponse.root)
}
inline ::hashdb::v1::Fea* GetResponse::release_root() {
  auto temp = unsafe_arena_release_root();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::hashdb::v1::Fea* GetResponse::unsafe_arena_release_root() {
  // @@protoc_insertion_point(field_release:hashdb.v1.GetResponse.root)
  
  ::hashdb::v1::Fea* temp = root_;
  root_ = nullptr;
  return temp;
}
inline ::hashdb::v1::Fea* GetResponse::_internal_mutable_root() {
  
  if (root_ == nullptr) {
    auto* p = CreateMaybeMessage<::hashdb::v1::Fea>(GetArena());
    root_ = p;
  }
  return root_;
}
inline ::hashdb::v1::Fea* GetResponse::mutable_root() {
  // @@protoc_insertion_point(field_mutable:hashdb.v1.GetResponse.root)
  return _internal_mutable_root();
}
inline void GetResponse::set_allocated_root(::hashdb::v1::Fea* root) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete root_;
  }
  if (root) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(root);
    if (message_arena != submessage_arena) {
      root = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, root, submessage_arena);
    }
    
  } else {
    
  }
  root_ = root;
  // @@protoc_insertion_point(field_set_allocated:hashdb.v1.GetResponse.root)
}

// .hashdb.v1.Fea key = 2;
inline bool GetResponse::_internal_has_key() const {
  return this != internal_default_instance() && key_ != nullptr;
}
inline bool GetResponse::has_key() const {
  return _internal_has_key();
}
inline void GetResponse::clear_key() {
  if (GetArena() == nullptr && key_ != nullptr) {
    delete key_;
  }
  key_ = nullptr;
}
inline const ::hashdb::v1::Fea& GetResponse::_internal_key() const {
  const ::hashdb::v1::Fea* p = key_;
  return p != nullptr ? *p : *reinterpret_cast<const ::hashdb::v1::Fea*>(
      &::hashdb::v1::_Fea_default_instance_);
}
inline const ::hashdb::v1::Fea& GetResponse::key() const {
  // @@protoc_insertion_point(field_get:hashdb.v1.GetResponse.key)
  return _internal_key();
}
inline void GetResponse::unsafe_arena_set_allocated_key(
    ::hashdb::v1::Fea* key) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(key_);
  }
  key_ = key;
  if (key) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:hashdb.v1.GetResponse.key)
}
inline ::hashdb::v1::Fea* GetResponse::release_key() {
  auto temp = unsafe_arena_release_key();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::hashdb::v1::Fea* GetResponse::unsafe_arena_release_key() {
  // @@protoc_insertion_point(field_release:hashdb.v1.GetResponse.key)
  
  ::hashdb::v1::Fea* temp = key_;
  key_ = nullptr;
  return temp;
}
inline ::hashdb::v1::Fea* GetResponse::_internal_mutable_key() {
  
  if (key_ == nullptr) {
    auto* p = CreateMaybeMessage<::hashdb::v1::Fea>(GetArena());
    key_ = p;
  }
  return key_;
}
inline ::hashdb::v1::Fea* GetResponse::mutable_key() {
  // @@protoc_insertion_point(field_mutable:hashdb.v1.GetResponse.key)
  return _internal_mutable_key();
}
inline void GetResponse::set_allocated_key(::hashdb::v1::Fea* key) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete key_;
  }
  if (key) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(key);
    if (message_arena != submessage_arena) {
      key = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, key, submessage_arena);
    }
    
  } else {
    
  }
  key_ = key;
  // @@protoc_insertion_point(field_set_allocated:hashdb.v1.GetResponse.key)
}

// map<uint64, .hashdb.v1.SiblingList> siblings = 3;
inline int GetResponse::_internal_siblings_size() const {
  return siblings_.size();
}
inline int GetResponse::siblings_size() const {
  return _internal_siblings_size();
}
inline void GetResponse::clear_siblings() {
  siblings_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< ::PROTOBUF_NAMESPACE_ID::uint64, ::hashdb::v1::SiblingList >&
GetResponse::_internal_siblings() const {
  return siblings_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< ::PROTOBUF_NAMESPACE_ID::uint64, ::hashdb::v1::SiblingList >&
GetResponse::siblings() const {
  // @@protoc_insertion_point(field_map:hashdb.v1.GetResponse.siblings)
  return _internal_siblings();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< ::PROTOBUF_NAMESPACE_ID::uint64, ::hashdb::v1::SiblingList >*
GetResponse::_internal_mutable_siblings() {
  return siblings_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< ::PROTOBUF_NAMESPACE_ID::uint64, ::hashdb::v1::SiblingList >*
GetResponse::mutable_siblings() {
  // @@protoc_insertion_point(field_mutable_map:hashdb.v1.GetResponse.siblings)
  return _internal_mutable_siblings();
}

// .hashdb.v1.Fea ins_key = 4;
inline bool GetResponse::_internal_has_ins_key() const {
  return this != internal_default_instance() && ins_key_ != nullptr;
}
inline bool GetResponse::has_ins_key() const {
  return _internal_has_ins_key();
}
inline void GetResponse::clear_ins_key() {
  if (GetArena() == nullptr && ins_key_ != nullptr) {
    delete ins_key_;
  }
  ins_key_ = nullptr;
}
inline const ::hashdb::v1::Fea& GetResponse::_internal_ins_key() const {
  const ::hashdb::v1::Fea* p = ins_key_;
  return p != nullptr ? *p : *reinterpret_cast<const ::hashdb::v1::Fea*>(
      &::hashdb::v1::_Fea_default_instance_);
}
inline const ::hashdb::v1::Fea& GetResponse::ins_key() const {
  // @@protoc_insertion_point(field_get:hashdb.v1.GetResponse.ins_key)
  return _internal_ins_key();
}
inline void GetResponse::unsafe_arena_set_allocated_ins_key(
    ::hashdb::v1::Fea* ins_key) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(ins_key_);
  }
  ins_key_ = ins_key;
  if (ins_key) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:hashdb.v1.GetResponse.ins_key)
}
inline ::hashdb::v1::Fea* GetResponse::release_ins_key() {
  auto temp = unsafe_arena_release_ins_key();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::hashdb::v1::Fea* GetResponse::unsafe_arena_release_ins_key() {
  // @@protoc_insertion_point(field_release:hashdb.v1.GetResponse.ins_key)
  
  ::hashdb::v1::Fea* temp = ins_key_;
  ins_key_ = nullptr;
  return temp;
}
inline ::hashdb::v1::Fea* GetResponse::_internal_mutable_ins_key() {
  
  if (ins_key_ == nullptr) {
    auto* p = CreateMaybeMessage<::hashdb::v1::Fea>(GetArena());
    ins_key_ = p;
  }
  return ins_key_;
}
inline ::hashdb::v1::Fea* GetResponse::mutable_ins_key() {
  // @@protoc_insertion_point(field_mutable:hashdb.v1.GetResponse.ins_key)
  return _internal_mutable_ins_key();
}
inline void GetResponse::set_allocated_ins_key(::hashdb::v1::Fea* ins_key) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete ins_key_;
  }
  if (ins_key) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(ins_key);
    if (message_arena != submessage_arena) {
      ins_key = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, ins_key, submessage_arena);
    }
    
  } else {
    
  }
  ins_key_ = ins_key;
  // @@protoc_insertion_point(field_set_allocated:hashdb.v1.GetResponse.ins_key)
}

// string ins_value = 5;
inline void GetResponse::clear_ins_value() {
  ins_value_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& GetResponse::ins_value() const {
  // @@protoc_insertion_point(field_get:hashdb.v1.GetResponse.ins_value)
  return _internal_ins_value();
}
inline void GetResponse::set_ins_value(const std::string& value) {
  _internal_set_ins_value(value);
  // @@protoc_insertion_point(field_set:hashdb.v1.GetResponse.ins_value)
}
inline std::string* GetResponse::mutable_ins_value() {
  // @@protoc_insertion_point(field_mutable:hashdb.v1.GetResponse.ins_value)
  return _internal_mutable_ins_value();
}
inline const std::string& GetResponse::_internal_ins_value() const {
  return ins_value_.Get();
}
inline void GetResponse::_internal_set_ins_value(const std::string& value) {
  
  ins_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void GetResponse::set_ins_value(std::string&& value) {
  
  ins_value_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:hashdb.v1.GetResponse.ins_value)
}
inline void GetResponse::set_ins_value(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  ins_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:hashdb.v1.GetResponse.ins_value)
}
inline void GetResponse::set_ins_value(const char* value,
    size_t size) {
  
  ins_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:hashdb.v1.GetResponse.ins_value)
}
inline std::string* GetResponse::_internal_mutable_ins_value() {
  
  return ins_value_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* GetResponse::release_ins_value() {
  // @@protoc_insertion_point(field_release:hashdb.v1.GetResponse.ins_value)
  return ins_value_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void GetResponse::set_allocated_ins_value(std::string* ins_value) {
  if (ins_value != nullptr) {
    
  } else {
    
  }
  ins_value_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ins_value,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:hashdb.v1.GetResponse.ins_value)
}
inline std::string* GetResponse::unsafe_arena_release_ins_value() {
  // @@protoc_insertion_point(field_unsafe_arena_release:hashdb.v1.GetResponse.ins_value)
  GOOGLE_DCHECK(GetArena() != nullptr);
  
  return ins_value_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void GetResponse::unsafe_arena_set_allocated_ins_value(
    std::string* ins_value) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (ins_value != nullptr) {
    
  } else {
    
  }
  ins_value_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ins_value, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:hashdb.v1.GetResponse.ins_value)
}

// bool is_old0 = 6;
inline void GetResponse::clear_is_old0() {
  is_old0_ = false;
}
inline bool GetResponse::_internal_is_old0() const {
  return is_old0_;
}
inline bool GetResponse::is_old0() const {
  // @@protoc_insertion_point(field_get:hashdb.v1.GetResponse.is_old0)
  return _internal_is_old0();
}
inline void GetResponse::_internal_set_is_old0(bool value) {
  
  is_old0_ = value;
}
inline void GetResponse::set_is_old0(bool value) {
  _internal_set_is_old0(value);
  // @@protoc_insertion_point(field_set:hashdb.v1.GetResponse.is_old0)
}

// string value = 7;
inline void GetResponse::clear_value() {
  value_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& GetResponse::value() const {
  // @@protoc_insertion_point(field_get:hashdb.v1.GetResponse.value)
  return _internal_value();
}
inline void GetResponse::set_value(const std::string& value) {
  _internal_set_value(value);
  // @@protoc_insertion_point(field_set:hashdb.v1.GetResponse.value)
}
inline std::string* GetResponse::mutable_value() {
  // @@protoc_insertion_point(field_mutable:hashdb.v1.GetResponse.value)
  return _internal_mutable_value();
}
inline const std::string& GetResponse::_internal_value() const {
  return value_.Get();
}
inline void GetResponse::_internal_set_value(const std::string& value) {
  
  value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void GetResponse::set_value(std::string&& value) {
  
  value_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:hashdb.v1.GetResponse.value)
}
inline void GetResponse::set_value(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:hashdb.v1.GetResponse.value)
}
inline void GetResponse::set_value(const char* value,
    size_t size) {
  
  value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:hashdb.v1.GetResponse.value)
}
inline std::string* GetResponse::_internal_mutable_value() {
  
  return value_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* GetResponse::release_value() {
  // @@protoc_insertion_point(field_release:hashdb.v1.GetResponse.value)
  return value_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void GetResponse::set_allocated_value(std::string* value) {
  if (value != nullptr) {
    
  } else {
    
  }
  value_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:hashdb.v1.GetResponse.value)
}
inline std::string* GetResponse::unsafe_arena_release_value() {
  // @@protoc_insertion_point(field_unsafe_arena_release:hashdb.v1.GetResponse.value)
  GOOGLE_DCHECK(GetArena() != nullptr);
  
  return value_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void GetResponse::unsafe_arena_set_allocated_value(
    std::string* value) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (value != nullptr) {
    
  } else {
    
  }
  value_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      value, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:hashdb.v1.GetResponse.value)
}

// uint64 proof_hash_counter = 8;
inline void GetResponse::clear_proof_hash_counter() {
  proof_hash_counter_ = PROTOBUF_ULONGLONG(0);
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 GetResponse::_internal_proof_hash_counter() const {
  return proof_hash_counter_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 GetResponse::proof_hash_counter() const {
  // @@protoc_insertion_point(field_get:hashdb.v1.GetResponse.proof_hash_counter)
  return _internal_proof_hash_counter();
}
inline void GetResponse::_internal_set_proof_hash_counter(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  
  proof_hash_counter_ = value;
}
inline void GetResponse::set_proof_hash_counter(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_proof_hash_counter(value);
  // @@protoc_insertion_point(field_set:hashdb.v1.GetResponse.proof_hash_counter)
}

// map<string, .hashdb.v1.FeList> db_read_log = 9;
inline int GetResponse::_internal_db_read_log_size() const {
  return db_read_log_.size();
}
inline int GetResponse::db_read_log_size() const {
  return _internal_db_read_log_size();
}
inline void GetResponse::clear_db_read_log() {
  db_read_log_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::hashdb::v1::FeList >&
GetResponse::_internal_db_read_log() const {
  return db_read_log_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::hashdb::v1::FeList >&
GetResponse::db_read_log() const {
  // @@protoc_insertion_point(field_map:hashdb.v1.GetResponse.db_read_log)
  return _internal_db_read_log();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::hashdb::v1::FeList >*
GetResponse::_internal_mutable_db_read_log() {
  return db_read_log_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::hashdb::v1::FeList >*
GetResponse::mutable_db_read_log() {
  // @@protoc_insertion_point(field_mutable_map:hashdb.v1.GetResponse.db_read_log)
  return _internal_mutable_db_read_log();
}

// .hashdb.v1.ResultCode result = 10;
inline bool GetResponse::_internal_has_result() const {
  return this != internal_default_instance() && result_ != nullptr;
}
inline bool GetResponse::has_result() const {
  return _internal_has_result();
}
inline void GetResponse::clear_result() {
  if (GetArena() == nullptr && result_ != nullptr) {
    delete result_;
  }
  result_ = nullptr;
}
inline const ::hashdb::v1::ResultCode& GetResponse::_internal_result() const {
  const ::hashdb::v1::ResultCode* p = result_;
  return p != nullptr ? *p : *reinterpret_cast<const ::hashdb::v1::ResultCode*>(
      &::hashdb::v1::_ResultCode_default_instance_);
}
inline const ::hashdb::v1::ResultCode& GetResponse::result() const {
  // @@protoc_insertion_point(field_get:hashdb.v1.GetResponse.result)
  return _internal_result();
}
inline void GetResponse::unsafe_arena_set_allocated_result(
    ::hashdb::v1::ResultCode* result) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(result_);
  }
  result_ = result;
  if (result) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:hashdb.v1.GetResponse.result)
}
inline ::hashdb::v1::ResultCode* GetResponse::release_result() {
  auto temp = unsafe_arena_release_result();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::hashdb::v1::ResultCode* GetResponse::unsafe_arena_release_result() {
  // @@protoc_insertion_point(field_release:hashdb.v1.GetResponse.result)
  
  ::hashdb::v1::ResultCode* temp = result_;
  result_ = nullptr;
  return temp;
}
inline ::hashdb::v1::ResultCode* GetResponse::_internal_mutable_result() {
  
  if (result_ == nullptr) {
    auto* p = CreateMaybeMessage<::hashdb::v1::ResultCode>(GetArena());
    result_ = p;
  }
  return result_;
}
inline ::hashdb::v1::ResultCode* GetResponse::mutable_result() {
  // @@protoc_insertion_point(field_mutable:hashdb.v1.GetResponse.result)
  return _internal_mutable_result();
}
inline void GetResponse::set_allocated_result(::hashdb::v1::ResultCode* result) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete result_;
  }
  if (result) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(result);
    if (message_arena != submessage_arena) {
      result = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, result, submessage_arena);
    }
    
  } else {
    
  }
  result_ = result;
  // @@protoc_insertion_point(field_set_allocated:hashdb.v1.GetResponse.result)
}

// -------------------------------------------------------------------

// SetProgramResponse

// .hashdb.v1.ResultCode result = 1;
inline bool SetProgramResponse::_internal_has_result() const {
  return this != internal_default_instance() && result_ != nullptr;
}
inline bool SetProgramResponse::has_result() const {
  return _internal_has_result();
}
inline void SetProgramResponse::clear_result() {
  if (GetArena() == nullptr && result_ != nullptr) {
    delete result_;
  }
  result_ = nullptr;
}
inline const ::hashdb::v1::ResultCode& SetProgramResponse::_internal_result() const {
  const ::hashdb::v1::ResultCode* p = result_;
  return p != nullptr ? *p : *reinterpret_cast<const ::hashdb::v1::ResultCode*>(
      &::hashdb::v1::_ResultCode_default_instance_);
}
inline const ::hashdb::v1::ResultCode& SetProgramResponse::result() const {
  // @@protoc_insertion_point(field_get:hashdb.v1.SetProgramResponse.result)
  return _internal_result();
}
inline void SetProgramResponse::unsafe_arena_set_allocated_result(
    ::hashdb::v1::ResultCode* result) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(result_);
  }
  result_ = result;
  if (result) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:hashdb.v1.SetProgramResponse.result)
}
inline ::hashdb::v1::ResultCode* SetProgramResponse::release_result() {
  auto temp = unsafe_arena_release_result();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::hashdb::v1::ResultCode* SetProgramResponse::unsafe_arena_release_result() {
  // @@protoc_insertion_point(field_release:hashdb.v1.SetProgramResponse.result)
  
  ::hashdb::v1::ResultCode* temp = result_;
  result_ = nullptr;
  return temp;
}
inline ::hashdb::v1::ResultCode* SetProgramResponse::_internal_mutable_result() {
  
  if (result_ == nullptr) {
    auto* p = CreateMaybeMessage<::hashdb::v1::ResultCode>(GetArena());
    result_ = p;
  }
  return result_;
}
inline ::hashdb::v1::ResultCode* SetProgramResponse::mutable_result() {
  // @@protoc_insertion_point(field_mutable:hashdb.v1.SetProgramResponse.result)
  return _internal_mutable_result();
}
inline void SetProgramResponse::set_allocated_result(::hashdb::v1::ResultCode* result) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete result_;
  }
  if (result) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(result);
    if (message_arena != submessage_arena) {
      result = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, result, submessage_arena);
    }
    
  } else {
    
  }
  result_ = result;
  // @@protoc_insertion_point(field_set_allocated:hashdb.v1.SetProgramResponse.result)
}

// -------------------------------------------------------------------

// GetProgramResponse

// bytes data = 1;
inline void GetProgramResponse::clear_data() {
  data_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& GetProgramResponse::data() const {
  // @@protoc_insertion_point(field_get:hashdb.v1.GetProgramResponse.data)
  return _internal_data();
}
inline void GetProgramResponse::set_data(const std::string& value) {
  _internal_set_data(value);
  // @@protoc_insertion_point(field_set:hashdb.v1.GetProgramResponse.data)
}
inline std::string* GetProgramResponse::mutable_data() {
  // @@protoc_insertion_point(field_mutable:hashdb.v1.GetProgramResponse.data)
  return _internal_mutable_data();
}
inline const std::string& GetProgramResponse::_internal_data() const {
  return data_.Get();
}
inline void GetProgramResponse::_internal_set_data(const std::string& value) {
  
  data_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void GetProgramResponse::set_data(std::string&& value) {
  
  data_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:hashdb.v1.GetProgramResponse.data)
}
inline void GetProgramResponse::set_data(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  data_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:hashdb.v1.GetProgramResponse.data)
}
inline void GetProgramResponse::set_data(const void* value,
    size_t size) {
  
  data_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:hashdb.v1.GetProgramResponse.data)
}
inline std::string* GetProgramResponse::_internal_mutable_data() {
  
  return data_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* GetProgramResponse::release_data() {
  // @@protoc_insertion_point(field_release:hashdb.v1.GetProgramResponse.data)
  return data_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void GetProgramResponse::set_allocated_data(std::string* data) {
  if (data != nullptr) {
    
  } else {
    
  }
  data_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), data,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:hashdb.v1.GetProgramResponse.data)
}
inline std::string* GetProgramResponse::unsafe_arena_release_data() {
  // @@protoc_insertion_point(field_unsafe_arena_release:hashdb.v1.GetProgramResponse.data)
  GOOGLE_DCHECK(GetArena() != nullptr);
  
  return data_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void GetProgramResponse::unsafe_arena_set_allocated_data(
    std::string* data) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (data != nullptr) {
    
  } else {
    
  }
  data_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      data, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:hashdb.v1.GetProgramResponse.data)
}

// .hashdb.v1.ResultCode result = 2;
inline bool GetProgramResponse::_internal_has_result() const {
  return this != internal_default_instance() && result_ != nullptr;
}
inline bool GetProgramResponse::has_result() const {
  return _internal_has_result();
}
inline void GetProgramResponse::clear_result() {
  if (GetArena() == nullptr && result_ != nullptr) {
    delete result_;
  }
  result_ = nullptr;
}
inline const ::hashdb::v1::ResultCode& GetProgramResponse::_internal_result() const {
  const ::hashdb::v1::ResultCode* p = result_;
  return p != nullptr ? *p : *reinterpret_cast<const ::hashdb::v1::ResultCode*>(
      &::hashdb::v1::_ResultCode_default_instance_);
}
inline const ::hashdb::v1::ResultCode& GetProgramResponse::result() const {
  // @@protoc_insertion_point(field_get:hashdb.v1.GetProgramResponse.result)
  return _internal_result();
}
inline void GetProgramResponse::unsafe_arena_set_allocated_result(
    ::hashdb::v1::ResultCode* result) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(result_);
  }
  result_ = result;
  if (result) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:hashdb.v1.GetProgramResponse.result)
}
inline ::hashdb::v1::ResultCode* GetProgramResponse::release_result() {
  auto temp = unsafe_arena_release_result();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::hashdb::v1::ResultCode* GetProgramResponse::unsafe_arena_release_result() {
  // @@protoc_insertion_point(field_release:hashdb.v1.GetProgramResponse.result)
  
  ::hashdb::v1::ResultCode* temp = result_;
  result_ = nullptr;
  return temp;
}
inline ::hashdb::v1::ResultCode* GetProgramResponse::_internal_mutable_result() {
  
  if (result_ == nullptr) {
    auto* p = CreateMaybeMessage<::hashdb::v1::ResultCode>(GetArena());
    result_ = p;
  }
  return result_;
}
inline ::hashdb::v1::ResultCode* GetProgramResponse::mutable_result() {
  // @@protoc_insertion_point(field_mutable:hashdb.v1.GetProgramResponse.result)
  return _internal_mutable_result();
}
inline void GetProgramResponse::set_allocated_result(::hashdb::v1::ResultCode* result) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete result_;
  }
  if (result) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(result);
    if (message_arena != submessage_arena) {
      result = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, result, submessage_arena);
    }
    
  } else {
    
  }
  result_ = result;
  // @@protoc_insertion_point(field_set_allocated:hashdb.v1.GetProgramResponse.result)
}

// -------------------------------------------------------------------

// FlushResponse

// uint64 flush_id = 1;
inline void FlushResponse::clear_flush_id() {
  flush_id_ = PROTOBUF_ULONGLONG(0);
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 FlushResponse::_internal_flush_id() const {
  return flush_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 FlushResponse::flush_id() const {
  // @@protoc_insertion_point(field_get:hashdb.v1.FlushResponse.flush_id)
  return _internal_flush_id();
}
inline void FlushResponse::_internal_set_flush_id(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  
  flush_id_ = value;
}
inline void FlushResponse::set_flush_id(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_flush_id(value);
  // @@protoc_insertion_point(field_set:hashdb.v1.FlushResponse.flush_id)
}

// uint64 stored_flush_id = 2;
inline void FlushResponse::clear_stored_flush_id() {
  stored_flush_id_ = PROTOBUF_ULONGLONG(0);
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 FlushResponse::_internal_stored_flush_id() const {
  return stored_flush_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 FlushResponse::stored_flush_id() const {
  // @@protoc_insertion_point(field_get:hashdb.v1.FlushResponse.stored_flush_id)
  return _internal_stored_flush_id();
}
inline void FlushResponse::_internal_set_stored_flush_id(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  
  stored_flush_id_ = value;
}
inline void FlushResponse::set_stored_flush_id(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_stored_flush_id(value);
  // @@protoc_insertion_point(field_set:hashdb.v1.FlushResponse.stored_flush_id)
}

// .hashdb.v1.ResultCode result = 3;
inline bool FlushResponse::_internal_has_result() const {
  return this != internal_default_instance() && result_ != nullptr;
}
inline bool FlushResponse::has_result() const {
  return _internal_has_result();
}
inline void FlushResponse::clear_result() {
  if (GetArena() == nullptr && result_ != nullptr) {
    delete result_;
  }
  result_ = nullptr;
}
inline const ::hashdb::v1::ResultCode& FlushResponse::_internal_result() const {
  const ::hashdb::v1::ResultCode* p = result_;
  return p != nullptr ? *p : *reinterpret_cast<const ::hashdb::v1::ResultCode*>(
      &::hashdb::v1::_ResultCode_default_instance_);
}
inline const ::hashdb::v1::ResultCode& FlushResponse::result() const {
  // @@protoc_insertion_point(field_get:hashdb.v1.FlushResponse.result)
  return _internal_result();
}
inline void FlushResponse::unsafe_arena_set_allocated_result(
    ::hashdb::v1::ResultCode* result) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(result_);
  }
  result_ = result;
  if (result) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:hashdb.v1.FlushResponse.result)
}
inline ::hashdb::v1::ResultCode* FlushResponse::release_result() {
  auto temp = unsafe_arena_release_result();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::hashdb::v1::ResultCode* FlushResponse::unsafe_arena_release_result() {
  // @@protoc_insertion_point(field_release:hashdb.v1.FlushResponse.result)
  
  ::hashdb::v1::ResultCode* temp = result_;
  result_ = nullptr;
  return temp;
}
inline ::hashdb::v1::ResultCode* FlushResponse::_internal_mutable_result() {
  
  if (result_ == nullptr) {
    auto* p = CreateMaybeMessage<::hashdb::v1::ResultCode>(GetArena());
    result_ = p;
  }
  return result_;
}
inline ::hashdb::v1::ResultCode* FlushResponse::mutable_result() {
  // @@protoc_insertion_point(field_mutable:hashdb.v1.FlushResponse.result)
  return _internal_mutable_result();
}
inline void FlushResponse::set_allocated_result(::hashdb::v1::ResultCode* result) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete result_;
  }
  if (result) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(result);
    if (message_arena != submessage_arena) {
      result = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, result, submessage_arena);
    }
    
  } else {
    
  }
  result_ = result;
  // @@protoc_insertion_point(field_set_allocated:hashdb.v1.FlushResponse.result)
}

// -------------------------------------------------------------------

// GetFlushStatusResponse

// uint64 stored_flush_id = 1;
inline void GetFlushStatusResponse::clear_stored_flush_id() {
  stored_flush_id_ = PROTOBUF_ULONGLONG(0);
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 GetFlushStatusResponse::_internal_stored_flush_id() const {
  return stored_flush_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 GetFlushStatusResponse::stored_flush_id() const {
  // @@protoc_insertion_point(field_get:hashdb.v1.GetFlushStatusResponse.stored_flush_id)
  return _internal_stored_flush_id();
}
inline void GetFlushStatusResponse::_internal_set_stored_flush_id(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  
  stored_flush_id_ = value;
}
inline void GetFlushStatusResponse::set_stored_flush_id(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_stored_flush_id(value);
  // @@protoc_insertion_point(field_set:hashdb.v1.GetFlushStatusResponse.stored_flush_id)
}

// uint64 storing_flush_id = 2;
inline void GetFlushStatusResponse::clear_storing_flush_id() {
  storing_flush_id_ = PROTOBUF_ULONGLONG(0);
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 GetFlushStatusResponse::_internal_storing_flush_id() const {
  return storing_flush_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 GetFlushStatusResponse::storing_flush_id() const {
  // @@protoc_insertion_point(field_get:hashdb.v1.GetFlushStatusResponse.storing_flush_id)
  return _internal_storing_flush_id();
}
inline void GetFlushStatusResponse::_internal_set_storing_flush_id(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  
  storing_flush_id_ = value;
}
inline void GetFlushStatusResponse::set_storing_flush_id(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_storing_flush_id(value);
  // @@protoc_insertion_point(field_set:hashdb.v1.GetFlushStatusResponse.storing_flush_id)
}

// uint64 last_flush_id = 3;
inline void GetFlushStatusResponse::clear_last_flush_id() {
  last_flush_id_ = PROTOBUF_ULONGLONG(0);
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 GetFlushStatusResponse::_internal_last_flush_id() const {
  return last_flush_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 GetFlushStatusResponse::last_flush_id() const {
  // @@protoc_insertion_point(field_get:hashdb.v1.GetFlushStatusResponse.last_flush_id)
  return _internal_last_flush_id();
}
inline void GetFlushStatusResponse::_internal_set_last_flush_id(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  
  last_flush_id_ = value;
}
inline void GetFlushStatusResponse::set_last_flush_id(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_last_flush_id(value);
  // @@protoc_insertion_point(field_set:hashdb.v1.GetFlushStatusResponse.last_flush_id)
}

// uint64 pending_to_flush_nodes = 4;
inline void GetFlushStatusResponse::clear_pending_to_flush_nodes() {
  pending_to_flush_nodes_ = PROTOBUF_ULONGLONG(0);
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 GetFlushStatusResponse::_internal_pending_to_flush_nodes() const {
  return pending_to_flush_nodes_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 GetFlushStatusResponse::pending_to_flush_nodes() const {
  // @@protoc_insertion_point(field_get:hashdb.v1.GetFlushStatusResponse.pending_to_flush_nodes)
  return _internal_pending_to_flush_nodes();
}
inline void GetFlushStatusResponse::_internal_set_pending_to_flush_nodes(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  
  pending_to_flush_nodes_ = value;
}
inline void GetFlushStatusResponse::set_pending_to_flush_nodes(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_pending_to_flush_nodes(value);
  // @@protoc_insertion_point(field_set:hashdb.v1.GetFlushStatusResponse.pending_to_flush_nodes)
}

// uint64 pending_to_flush_program = 5;
inline void GetFlushStatusResponse::clear_pending_to_flush_program() {
  pending_to_flush_program_ = PROTOBUF_ULONGLONG(0);
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 GetFlushStatusResponse::_internal_pending_to_flush_program() const {
  return pending_to_flush_program_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 GetFlushStatusResponse::pending_to_flush_program() const {
  // @@protoc_insertion_point(field_get:hashdb.v1.GetFlushStatusResponse.pending_to_flush_program)
  return _internal_pending_to_flush_program();
}
inline void GetFlushStatusResponse::_internal_set_pending_to_flush_program(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  
  pending_to_flush_program_ = value;
}
inline void GetFlushStatusResponse::set_pending_to_flush_program(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_pending_to_flush_program(value);
  // @@protoc_insertion_point(field_set:hashdb.v1.GetFlushStatusResponse.pending_to_flush_program)
}

// uint64 storing_nodes = 6;
inline void GetFlushStatusResponse::clear_storing_nodes() {
  storing_nodes_ = PROTOBUF_ULONGLONG(0);
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 GetFlushStatusResponse::_internal_storing_nodes() const {
  return storing_nodes_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 GetFlushStatusResponse::storing_nodes() const {
  // @@protoc_insertion_point(field_get:hashdb.v1.GetFlushStatusResponse.storing_nodes)
  return _internal_storing_nodes();
}
inline void GetFlushStatusResponse::_internal_set_storing_nodes(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  
  storing_nodes_ = value;
}
inline void GetFlushStatusResponse::set_storing_nodes(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_storing_nodes(value);
  // @@protoc_insertion_point(field_set:hashdb.v1.GetFlushStatusResponse.storing_nodes)
}

// uint64 storing_program = 7;
inline void GetFlushStatusResponse::clear_storing_program() {
  storing_program_ = PROTOBUF_ULONGLONG(0);
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 GetFlushStatusResponse::_internal_storing_program() const {
  return storing_program_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 GetFlushStatusResponse::storing_program() const {
  // @@protoc_insertion_point(field_get:hashdb.v1.GetFlushStatusResponse.storing_program)
  return _internal_storing_program();
}
inline void GetFlushStatusResponse::_internal_set_storing_program(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  
  storing_program_ = value;
}
inline void GetFlushStatusResponse::set_storing_program(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_storing_program(value);
  // @@protoc_insertion_point(field_set:hashdb.v1.GetFlushStatusResponse.storing_program)
}

// string prover_id = 8;
inline void GetFlushStatusResponse::clear_prover_id() {
  prover_id_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& GetFlushStatusResponse::prover_id() const {
  // @@protoc_insertion_point(field_get:hashdb.v1.GetFlushStatusResponse.prover_id)
  return _internal_prover_id();
}
inline void GetFlushStatusResponse::set_prover_id(const std::string& value) {
  _internal_set_prover_id(value);
  // @@protoc_insertion_point(field_set:hashdb.v1.GetFlushStatusResponse.prover_id)
}
inline std::string* GetFlushStatusResponse::mutable_prover_id() {
  // @@protoc_insertion_point(field_mutable:hashdb.v1.GetFlushStatusResponse.prover_id)
  return _internal_mutable_prover_id();
}
inline const std::string& GetFlushStatusResponse::_internal_prover_id() const {
  return prover_id_.Get();
}
inline void GetFlushStatusResponse::_internal_set_prover_id(const std::string& value) {
  
  prover_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void GetFlushStatusResponse::set_prover_id(std::string&& value) {
  
  prover_id_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:hashdb.v1.GetFlushStatusResponse.prover_id)
}
inline void GetFlushStatusResponse::set_prover_id(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  prover_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:hashdb.v1.GetFlushStatusResponse.prover_id)
}
inline void GetFlushStatusResponse::set_prover_id(const char* value,
    size_t size) {
  
  prover_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:hashdb.v1.GetFlushStatusResponse.prover_id)
}
inline std::string* GetFlushStatusResponse::_internal_mutable_prover_id() {
  
  return prover_id_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* GetFlushStatusResponse::release_prover_id() {
  // @@protoc_insertion_point(field_release:hashdb.v1.GetFlushStatusResponse.prover_id)
  return prover_id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void GetFlushStatusResponse::set_allocated_prover_id(std::string* prover_id) {
  if (prover_id != nullptr) {
    
  } else {
    
  }
  prover_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), prover_id,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:hashdb.v1.GetFlushStatusResponse.prover_id)
}
inline std::string* GetFlushStatusResponse::unsafe_arena_release_prover_id() {
  // @@protoc_insertion_point(field_unsafe_arena_release:hashdb.v1.GetFlushStatusResponse.prover_id)
  GOOGLE_DCHECK(GetArena() != nullptr);
  
  return prover_id_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void GetFlushStatusResponse::unsafe_arena_set_allocated_prover_id(
    std::string* prover_id) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (prover_id != nullptr) {
    
  } else {
    
  }
  prover_id_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      prover_id, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:hashdb.v1.GetFlushStatusResponse.prover_id)
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// GetFlushDataResponse

// uint64 stored_flush_id = 1;
inline void GetFlushDataResponse::clear_stored_flush_id() {
  stored_flush_id_ = PROTOBUF_ULONGLONG(0);
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 GetFlushDataResponse::_internal_stored_flush_id() const {
  return stored_flush_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 GetFlushDataResponse::stored_flush_id() const {
  // @@protoc_insertion_point(field_get:hashdb.v1.GetFlushDataResponse.stored_flush_id)
  return _internal_stored_flush_id();
}
inline void GetFlushDataResponse::_internal_set_stored_flush_id(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  
  stored_flush_id_ = value;
}
inline void GetFlushDataResponse::set_stored_flush_id(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_stored_flush_id(value);
  // @@protoc_insertion_point(field_set:hashdb.v1.GetFlushDataResponse.stored_flush_id)
}

// map<string, string> nodes = 2;
inline int GetFlushDataResponse::_internal_nodes_size() const {
  return nodes_.size();
}
inline int GetFlushDataResponse::nodes_size() const {
  return _internal_nodes_size();
}
inline void GetFlushDataResponse::clear_nodes() {
  nodes_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
GetFlushDataResponse::_internal_nodes() const {
  return nodes_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
GetFlushDataResponse::nodes() const {
  // @@protoc_insertion_point(field_map:hashdb.v1.GetFlushDataResponse.nodes)
  return _internal_nodes();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
GetFlushDataResponse::_internal_mutable_nodes() {
  return nodes_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
GetFlushDataResponse::mutable_nodes() {
  // @@protoc_insertion_point(field_mutable_map:hashdb.v1.GetFlushDataResponse.nodes)
  return _internal_mutable_nodes();
}

// map<string, string> program = 3;
inline int GetFlushDataResponse::_internal_program_size() const {
  return program_.size();
}
inline int GetFlushDataResponse::program_size() const {
  return _internal_program_size();
}
inline void GetFlushDataResponse::clear_program() {
  program_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
GetFlushDataResponse::_internal_program() const {
  return program_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
GetFlushDataResponse::program() const {
  // @@protoc_insertion_point(field_map:hashdb.v1.GetFlushDataResponse.program)
  return _internal_program();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
GetFlushDataResponse::_internal_mutable_program() {
  return program_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
GetFlushDataResponse::mutable_program() {
  // @@protoc_insertion_point(field_mutable_map:hashdb.v1.GetFlushDataResponse.program)
  return _internal_mutable_program();
}

// string nodes_state_root = 4;
inline void GetFlushDataResponse::clear_nodes_state_root() {
  nodes_state_root_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& GetFlushDataResponse::nodes_state_root() const {
  // @@protoc_insertion_point(field_get:hashdb.v1.GetFlushDataResponse.nodes_state_root)
  return _internal_nodes_state_root();
}
inline void GetFlushDataResponse::set_nodes_state_root(const std::string& value) {
  _internal_set_nodes_state_root(value);
  // @@protoc_insertion_point(field_set:hashdb.v1.GetFlushDataResponse.nodes_state_root)
}
inline std::string* GetFlushDataResponse::mutable_nodes_state_root() {
  // @@protoc_insertion_point(field_mutable:hashdb.v1.GetFlushDataResponse.nodes_state_root)
  return _internal_mutable_nodes_state_root();
}
inline const std::string& GetFlushDataResponse::_internal_nodes_state_root() const {
  return nodes_state_root_.Get();
}
inline void GetFlushDataResponse::_internal_set_nodes_state_root(const std::string& value) {
  
  nodes_state_root_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void GetFlushDataResponse::set_nodes_state_root(std::string&& value) {
  
  nodes_state_root_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:hashdb.v1.GetFlushDataResponse.nodes_state_root)
}
inline void GetFlushDataResponse::set_nodes_state_root(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  nodes_state_root_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:hashdb.v1.GetFlushDataResponse.nodes_state_root)
}
inline void GetFlushDataResponse::set_nodes_state_root(const char* value,
    size_t size) {
  
  nodes_state_root_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:hashdb.v1.GetFlushDataResponse.nodes_state_root)
}
inline std::string* GetFlushDataResponse::_internal_mutable_nodes_state_root() {
  
  return nodes_state_root_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* GetFlushDataResponse::release_nodes_state_root() {
  // @@protoc_insertion_point(field_release:hashdb.v1.GetFlushDataResponse.nodes_state_root)
  return nodes_state_root_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void GetFlushDataResponse::set_allocated_nodes_state_root(std::string* nodes_state_root) {
  if (nodes_state_root != nullptr) {
    
  } else {
    
  }
  nodes_state_root_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), nodes_state_root,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:hashdb.v1.GetFlushDataResponse.nodes_state_root)
}
inline std::string* GetFlushDataResponse::unsafe_arena_release_nodes_state_root() {
  // @@protoc_insertion_point(field_unsafe_arena_release:hashdb.v1.GetFlushDataResponse.nodes_state_root)
  GOOGLE_DCHECK(GetArena() != nullptr);
  
  return nodes_state_root_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void GetFlushDataResponse::unsafe_arena_set_allocated_nodes_state_root(
    std::string* nodes_state_root) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (nodes_state_root != nullptr) {
    
  } else {
    
  }
  nodes_state_root_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      nodes_state_root, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:hashdb.v1.GetFlushDataResponse.nodes_state_root)
}

// .hashdb.v1.ResultCode result = 5;
inline bool GetFlushDataResponse::_internal_has_result() const {
  return this != internal_default_instance() && result_ != nullptr;
}
inline bool GetFlushDataResponse::has_result() const {
  return _internal_has_result();
}
inline void GetFlushDataResponse::clear_result() {
  if (GetArena() == nullptr && result_ != nullptr) {
    delete result_;
  }
  result_ = nullptr;
}
inline const ::hashdb::v1::ResultCode& GetFlushDataResponse::_internal_result() const {
  const ::hashdb::v1::ResultCode* p = result_;
  return p != nullptr ? *p : *reinterpret_cast<const ::hashdb::v1::ResultCode*>(
      &::hashdb::v1::_ResultCode_default_instance_);
}
inline const ::hashdb::v1::ResultCode& GetFlushDataResponse::result() const {
  // @@protoc_insertion_point(field_get:hashdb.v1.GetFlushDataResponse.result)
  return _internal_result();
}
inline void GetFlushDataResponse::unsafe_arena_set_allocated_result(
    ::hashdb::v1::ResultCode* result) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(result_);
  }
  result_ = result;
  if (result) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:hashdb.v1.GetFlushDataResponse.result)
}
inline ::hashdb::v1::ResultCode* GetFlushDataResponse::release_result() {
  auto temp = unsafe_arena_release_result();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::hashdb::v1::ResultCode* GetFlushDataResponse::unsafe_arena_release_result() {
  // @@protoc_insertion_point(field_release:hashdb.v1.GetFlushDataResponse.result)
  
  ::hashdb::v1::ResultCode* temp = result_;
  result_ = nullptr;
  return temp;
}
inline ::hashdb::v1::ResultCode* GetFlushDataResponse::_internal_mutable_result() {
  
  if (result_ == nullptr) {
    auto* p = CreateMaybeMessage<::hashdb::v1::ResultCode>(GetArena());
    result_ = p;
  }
  return result_;
}
inline ::hashdb::v1::ResultCode* GetFlushDataResponse::mutable_result() {
  // @@protoc_insertion_point(field_mutable:hashdb.v1.GetFlushDataResponse.result)
  return _internal_mutable_result();
}
inline void GetFlushDataResponse::set_allocated_result(::hashdb::v1::ResultCode* result) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete result_;
  }
  if (result) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(result);
    if (message_arena != submessage_arena) {
      result = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, result, submessage_arena);
    }
    
  } else {
    
  }
  result_ = result;
  // @@protoc_insertion_point(field_set_allocated:hashdb.v1.GetFlushDataResponse.result)
}

// -------------------------------------------------------------------

// Fea

// uint64 fe0 = 1;
inline void Fea::clear_fe0() {
  fe0_ = PROTOBUF_ULONGLONG(0);
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 Fea::_internal_fe0() const {
  return fe0_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 Fea::fe0() const {
  // @@protoc_insertion_point(field_get:hashdb.v1.Fea.fe0)
  return _internal_fe0();
}
inline void Fea::_internal_set_fe0(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  
  fe0_ = value;
}
inline void Fea::set_fe0(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_fe0(value);
  // @@protoc_insertion_point(field_set:hashdb.v1.Fea.fe0)
}

// uint64 fe1 = 2;
inline void Fea::clear_fe1() {
  fe1_ = PROTOBUF_ULONGLONG(0);
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 Fea::_internal_fe1() const {
  return fe1_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 Fea::fe1() const {
  // @@protoc_insertion_point(field_get:hashdb.v1.Fea.fe1)
  return _internal_fe1();
}
inline void Fea::_internal_set_fe1(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  
  fe1_ = value;
}
inline void Fea::set_fe1(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_fe1(value);
  // @@protoc_insertion_point(field_set:hashdb.v1.Fea.fe1)
}

// uint64 fe2 = 3;
inline void Fea::clear_fe2() {
  fe2_ = PROTOBUF_ULONGLONG(0);
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 Fea::_internal_fe2() const {
  return fe2_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 Fea::fe2() const {
  // @@protoc_insertion_point(field_get:hashdb.v1.Fea.fe2)
  return _internal_fe2();
}
inline void Fea::_internal_set_fe2(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  
  fe2_ = value;
}
inline void Fea::set_fe2(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_fe2(value);
  // @@protoc_insertion_point(field_set:hashdb.v1.Fea.fe2)
}

// uint64 fe3 = 4;
inline void Fea::clear_fe3() {
  fe3_ = PROTOBUF_ULONGLONG(0);
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 Fea::_internal_fe3() const {
  return fe3_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 Fea::fe3() const {
  // @@protoc_insertion_point(field_get:hashdb.v1.Fea.fe3)
  return _internal_fe3();
}
inline void Fea::_internal_set_fe3(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  
  fe3_ = value;
}
inline void Fea::set_fe3(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_fe3(value);
  // @@protoc_insertion_point(field_set:hashdb.v1.Fea.fe3)
}

// -------------------------------------------------------------------

// FeList

// repeated uint64 fe = 1;
inline int FeList::_internal_fe_size() const {
  return fe_.size();
}
inline int FeList::fe_size() const {
  return _internal_fe_size();
}
inline void FeList::clear_fe() {
  fe_.Clear();
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 FeList::_internal_fe(int index) const {
  return fe_.Get(index);
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 FeList::fe(int index) const {
  // @@protoc_insertion_point(field_get:hashdb.v1.FeList.fe)
  return _internal_fe(index);
}
inline void FeList::set_fe(int index, ::PROTOBUF_NAMESPACE_ID::uint64 value) {
  fe_.Set(index, value);
  // @@protoc_insertion_point(field_set:hashdb.v1.FeList.fe)
}
inline void FeList::_internal_add_fe(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  fe_.Add(value);
}
inline void FeList::add_fe(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_add_fe(value);
  // @@protoc_insertion_point(field_add:hashdb.v1.FeList.fe)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::uint64 >&
FeList::_internal_fe() const {
  return fe_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::uint64 >&
FeList::fe() const {
  // @@protoc_insertion_point(field_list:hashdb.v1.FeList.fe)
  return _internal_fe();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::uint64 >*
FeList::_internal_mutable_fe() {
  return &fe_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::uint64 >*
FeList::mutable_fe() {
  // @@protoc_insertion_point(field_mutable_list:hashdb.v1.FeList.fe)
  return _internal_mutable_fe();
}

// -------------------------------------------------------------------

// SiblingList

// repeated uint64 sibling = 1;
inline int SiblingList::_internal_sibling_size() const {
  return sibling_.size();
}
inline int SiblingList::sibling_size() const {
  return _internal_sibling_size();
}
inline void SiblingList::clear_sibling() {
  sibling_.Clear();
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 SiblingList::_internal_sibling(int index) const {
  return sibling_.Get(index);
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 SiblingList::sibling(int index) const {
  // @@protoc_insertion_point(field_get:hashdb.v1.SiblingList.sibling)
  return _internal_sibling(index);
}
inline void SiblingList::set_sibling(int index, ::PROTOBUF_NAMESPACE_ID::uint64 value) {
  sibling_.Set(index, value);
  // @@protoc_insertion_point(field_set:hashdb.v1.SiblingList.sibling)
}
inline void SiblingList::_internal_add_sibling(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  sibling_.Add(value);
}
inline void SiblingList::add_sibling(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_add_sibling(value);
  // @@protoc_insertion_point(field_add:hashdb.v1.SiblingList.sibling)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::uint64 >&
SiblingList::_internal_sibling() const {
  return sibling_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::uint64 >&
SiblingList::sibling() const {
  // @@protoc_insertion_point(field_list:hashdb.v1.SiblingList.sibling)
  return _internal_sibling();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::uint64 >*
SiblingList::_internal_mutable_sibling() {
  return &sibling_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::uint64 >*
SiblingList::mutable_sibling() {
  // @@protoc_insertion_point(field_mutable_list:hashdb.v1.SiblingList.sibling)
  return _internal_mutable_sibling();
}

// -------------------------------------------------------------------

// ResultCode

// .hashdb.v1.ResultCode.Code code = 1;
inline void ResultCode::clear_code() {
  code_ = 0;
}
inline ::hashdb::v1::ResultCode_Code ResultCode::_internal_code() const {
  return static_cast< ::hashdb::v1::ResultCode_Code >(code_);
}
inline ::hashdb::v1::ResultCode_Code ResultCode::code() const {
  // @@protoc_insertion_point(field_get:hashdb.v1.ResultCode.code)
  return _internal_code();
}
inline void ResultCode::_internal_set_code(::hashdb::v1::ResultCode_Code value) {
  
  code_ = value;
}
inline void ResultCode::set_code(::hashdb::v1::ResultCode_Code value) {
  _internal_set_code(value);
  // @@protoc_insertion_point(field_set:hashdb.v1.ResultCode.code)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace v1
}  // namespace hashdb

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::hashdb::v1::ResultCode_Code> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::hashdb::v1::ResultCode_Code>() {
  return ::hashdb::v1::ResultCode_Code_descriptor();
}
template <> struct is_proto_enum< ::hashdb::v1::Persistence> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::hashdb::v1::Persistence>() {
  return ::hashdb::v1::Persistence_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_hashdb_2eproto
